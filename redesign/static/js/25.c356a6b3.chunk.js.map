{"version":3,"sources":["../node_modules/@ambire/signature-validator/index.js","../node_modules/ambire-common/src/constants/supportedDApps.ts","../node_modules/ambire-common/src/hooks/useSignMessage/useSignMessage.ts","../node_modules/ambire-common/src/services/getNetwork/getNetwork.ts","../node_modules/ambire-common/src/hooks/useSignMessage/index.ts","../node_modules/adex-protocol-eth/js/ensureTypes.js","../node_modules/adex-protocol-eth/js/Bundle.js"],"names":["ethers","require","VALIDATOR_1271_ABI","verifyMessage","provider","signer","message","typedData","finalDigest","signature","undeployedCallback","utils","hashMessage","domain","types","Error","_TypedDataEncoder","hash","addrMatching","recoverAddress","eip1271Check","recoveredAddr","targetAddr","isAddress","toLowerCase","web3CompatibleProvider","ethersProvider","providers","Provider","isProvider","Web3Provider","getCode","code","contract","Contract","isValidSignature","module","exports","supportedDApps","getMessageAsBytes","msg","isHexString","arrayify","toUtf8Bytes","useSignMessage","typeDataErr","dataV4","fetch","account","everythingToSign","relayerURL","addToast","resolve","onConfirmationCodeRequired","onLastMessageSign","getHardwareWallet","useState","isLoading","setLoading","isDeployed","setIsDeployed","hasPrivileges","setHasPrivileges","hasProviderError","setHasProviderError","confirmationType","setConfirmationType","toSign","useMemo","requestedChainId","chainId","isTypedData","indexOf","type","txn","startsWith","JSON","parse","error","EIP712Domain","requestedNetwork","networks","find","n","parseInt","toString","checkIsDeployedAndHasPrivileges","useCallback","a","bundle","Bundle","network","id","identity","getProvider","quickAccManager","quickAccTimelock","accountPresets","quickAccountTuple","one","two","abiCoder","AbiCoder","quickAccAccountHash","keccak256","encode","privilegeAddress","address","callObject","method","params","to","data","substring","jsonrpc","fetchPost","connection","url","then","result","catch","err","useEffect","handleSigningErr","e","includes","verifySignature","sig","networkId","verificationResult","approveQuickAcc","credentials","password","length","undefined","success","confCodeRequired","primaryKeyBackup","Wallet","fromEncryptedJson","wallet","signMessage712","signMessage","approve","device","BN","Address","x","Bytes32","b","Buffer","from","slice","isBuffer","Uint256","bn","isNeg","Bytes","Bytes32Array","bytes32Array","size","map","Channel","channel","leader","follower","guardian","tokenAddr","nonce","hexlify","Interface","BigNumber","ensure","IdentityABI","QuickAccManagerABI","IdentityInterface","args","this","txns","gasLimit","minFeeInUSDPerGas","recoveryMode","meta","gasTankFee","prototype","getNonce","estimate","replacing","getNextNonce","gasTank","queryParams","Object","fromEntries","entries","filter","URLSearchParams","res","sign","isSingleSigMode","isNaN","encoded","getSignable","signMsg","submit","signatureTwo","cancel","UNPREDICTABLE_GAS_REGEX","signatureOne","sigInner","timelock","value","signMsg712","userTxnBundle","getChainID","accHash","mapSignatureV","sigRaw","useFinalDigestSigMode","_signTypedData","typedDataSign","nonces","toNumber","body","headers","stringify","r","json","estimateNoRelayer","txParams","encodeFunctionData","blockTag","estimateGasWithCatch","match","getErrMsg","getFeeData","feeData","gasPrice","baseFee","feeInNative","slow","medium","fast","ape","ERROR_SIG","call","returnData","decode","tx","send"],"mappings":"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","file":"static/js/25.c356a6b3.chunk.js","sourcesContent":["const { ethers } = require('ethers')\n\nconst VALIDATOR_1271_ABI = ['function isValidSignature(bytes32 hash, bytes signature) view returns (bytes4)']\n\n/**\n * @typedef { import(\"@ethersproject/abstract-signer\").TypedDataDomain } TypedDataDomain\n * @typedef { import(\"@ethersproject/abstract-signer\").TypedDataField } TypedDataField\n * @typedef { import(\"@ethersproject/providers\").Provider } Provider\n */\n\n/**\n * @param {Provider | window.ethereum} provider Web3 Compatible provider to perform smart contract wallet validation with EIP 1271 (window.ethereum, web3.currentProvider, ethers provider... )\n * @param {string} signer The signer address to verify the signature against\n * @param {string | Uint8Array} message To verify eth_sign type of signatures. Human-readable message to verify. Message should be a human string or the hex version of the human string encoded as Uint8Array. If a hex string is passed, it will be considered as a regular string\n * @param {{domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>}} typedData To verify a 712 signature type. The {domain, type, message} 712 message object\n * @param {string} finalDigest The final digest to verify. dApp will have to pre-compute the hash as no hashing transformation will occur and this digest will be directly used for recoverAddress and isValidSignature\n * @param {string | Uint8Array} signature The signature to verify as a hex string or Uint8Array\n * @param {function(string, string, string | Uint8Array): boolean} undeployedCallback An optional 1271 callback function to gracefully handle signature validation for non-deployed smart contract wallets\n * @returns {Promise<boolean>}\n * NOTE: you only need to pass one of: typedData, finalDigest, message\n */\nconst  verifyMessage = async ({ provider, signer, message, typedData, finalDigest, signature, undeployedCallback }) => {\n  if (message) {\n    finalDigest = ethers.utils.hashMessage(message)\n  } else if (typedData) {\n    if (!typedData.domain || !typedData.types || !typedData.message) {\n      throw Error('Missing one or more properties for typedData (domain, types, message)')\n    }\n\n    finalDigest = ethers.utils._TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message)\n  } else if (!finalDigest) {\n    throw Error('Missing one of the properties: message, unPrefixedMessage, typedData or finalDigest')\n  }\n\n  // First try: elliptic curve signature (EOA)\n  if (addrMatching(recoverAddress(finalDigest, signature), signer)) return true\n\n  // 2nd try: Getting code from deployed smart contract to call 1271 isValidSignature\n  if ((await eip1271Check(provider, signer, finalDigest, signature)) === '0x1626ba7e') return true\n\n  // Last attempt, for undeployed smart contract with custom logic\n  if (undeployedCallback) {\n    try {\n      if (undeployedCallback(signer, finalDigest, signature)) return true\n    } catch (e) {\n      throw new Error('undeployedCallback error: ' + e.message)\n    }\n  }\n\n  return false\n}\n\n// Address recovery wrapper\nconst recoverAddress = (hash, signature) => {\n  try {\n    return ethers.utils.recoverAddress(hash, signature);\n  } catch {\n    return false\n  }\n}\n\n// Comparing addresses. targetAddr is already checked upstream\nconst addrMatching = (recoveredAddr, targetAddr) => {\n  if (recoveredAddr === false) return false\n  if (!ethers.utils.isAddress(recoveredAddr)) throw new Error('Invalid recovered address: ' + recoveredAddr)\n\n  return recoveredAddr.toLowerCase() === targetAddr.toLowerCase()\n}\n\n// EIP 1271 check\nconst eip1271Check = async (web3CompatibleProvider, signer, hash, signature) => {\n  let ethersProvider\n  if (ethers.providers.Provider.isProvider(web3CompatibleProvider)) {\n    ethersProvider = web3CompatibleProvider\n  } else {\n    ethersProvider = new ethers.providers.Web3Provider(web3CompatibleProvider);\n  }\n  const code = await ethersProvider.getCode(signer)\n  if (code && code !== '0x') {\n    const contract = new ethers.Contract(signer, VALIDATOR_1271_ABI, ethersProvider)\n    return contract.isValidSignature(hash, signature)\n  }\n  return false\n}\n\nmodule.exports = {\n  verifyMessage\n}\n","const supportedDApps: string[] = [\n  'https://snapshot.org',\n  'https://guild.xyz',\n  'https://sudoswap.xyz',\n  'https://evm-sigtools.ambire.com',\n  'https://app.swappin.gifts'\n]\n\nexport default supportedDApps\n","// @ts-nocheck TODO: Fill in all missing types before enabling the TS check again\nimport { Bundle, signMessage, signMessage712 } from 'adex-protocol-eth/js/Bundle'\nimport { Wallet } from 'ethers'\nimport {\n  _TypedDataEncoder,\n  AbiCoder,\n  arrayify,\n  isHexString,\n  keccak256,\n  toUtf8Bytes\n} from 'ethers/lib/utils'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\n\nimport { verifyMessage } from '@ambire/signature-validator'\n\nimport accountPresets from '../../constants/accountPresets'\nimport { fetchPost } from '../../services/fetch'\nimport { getNetworkByChainId } from '../../services/getNetwork'\nimport { getProvider } from '../../services/provider'\nimport { UseSignMessageProps, UseSignMessageReturnType } from './types'\n\nfunction getMessageAsBytes(msg: string) {\n  // Transforming human message / hex string to bytes\n  if (!isHexString(msg)) {\n    return toUtf8Bytes(msg)\n  }\n  return arrayify(msg)\n}\n\nconst useSignMessage = ({\n  fetch,\n  account,\n  everythingToSign,\n  relayerURL,\n  addToast,\n  resolve,\n  onConfirmationCodeRequired,\n  onLastMessageSign,\n  getHardwareWallet\n}: UseSignMessageProps): UseSignMessageReturnType => {\n  const [isLoading, setLoading] = useState<boolean>(false)\n  const [isDeployed, setIsDeployed] = useState<null | boolean>(null)\n  const [hasPrivileges, setHasPrivileges] = useState<null | boolean>(null)\n  const [hasProviderError, setHasProviderError] = useState(null)\n  const [confirmationType, setConfirmationType] = useState<'email' | 'otp' | null>(null)\n\n  const toSign = useMemo(() => everythingToSign[0] || {}, [everythingToSign])\n\n  let typeDataErr\n  let dataV4: any\n  let requestedChainId = toSign.chainId\n  const isTypedData = ['eth_signTypedData_v4', 'eth_signTypedData'].indexOf(toSign?.type) !== -1\n  if (isTypedData) {\n    dataV4 = toSign.txn\n    try {\n      if (dataV4.startsWith('{')) {\n        dataV4 = JSON.parse(toSign.txn)\n      }\n    } catch (error) {\n      dataV4 = toSign.txn\n    }\n    if (typeof dataV4 === 'object' && dataV4 !== null) {\n      try {\n        if (dataV4?.types?.EIP712Domain) {\n          // Avoids failure in case some dapps explicitly add this (redundant) prop\n          delete dataV4?.types?.EIP712Domain\n        }\n        _TypedDataEncoder.hash(dataV4?.domain, dataV4.types, dataV4?.message)\n        // enforce chainId\n        if (dataV4.domain?.chainId) {\n          requestedChainId = dataV4.domain?.chainId\n        }\n      } catch {\n        typeDataErr = '.txn has Invalid TypedData object. Should be {domain, types, message}'\n      }\n    } else {\n      typeDataErr = '.txn should be a TypedData object'\n    }\n  }\n\n  const requestedNetwork = getNetworkByChainId(requestedChainId)\n\n  const checkIsDeployedAndHasPrivileges = useCallback(async () => {\n    if (!requestedNetwork) return\n\n    const bundle = new Bundle({\n      network: requestedNetwork?.id,\n      identity: account?.id,\n      signer: account?.signer\n    })\n\n    const provider = await getProvider(requestedNetwork?.id)\n\n    let privilegeAddress: any\n    let quickAccAccountHash: any\n    if (account?.signer?.quickAccManager) {\n      const { quickAccTimelock } = accountPresets\n      const quickAccountTuple = [quickAccTimelock, account?.signer?.one, account?.signer?.two]\n      const abiCoder = new AbiCoder()\n      quickAccAccountHash = keccak256(\n        abiCoder.encode(['tuple(uint, address, address)'], [quickAccountTuple])\n      )\n      privilegeAddress = account.signer?.quickAccManager\n    } else {\n      privilegeAddress = account.signer?.address\n    }\n\n    // to differenciate reverts and network issues\n    const callObject = {\n      method: 'eth_call',\n      params: [\n        {\n          to: bundle.identity,\n          data: `0xc066a5b1000000000000000000000000${privilegeAddress.toLowerCase().substring(2)}`\n        },\n        'latest'\n      ],\n      id: 1,\n      jsonrpc: '2.0'\n    }\n\n    fetchPost(fetch, provider?.connection?.url, callObject)\n      .then((result: any) => {\n        if (result.result && result.result !== '0x') {\n          setIsDeployed(true)\n          if (account?.signer?.quickAccManager) {\n            setHasPrivileges(result.result === quickAccAccountHash)\n          } else {\n            // TODO: To ask : in what cases it's more than 1?\n            // eslint-disable-next-line no-lonely-if\n            if (\n              result.result === '0x0000000000000000000000000000000000000000000000000000000000000001'\n            ) {\n              setHasPrivileges(true)\n            } else {\n              setHasPrivileges(false)\n            }\n          }\n        } else {\n          // result.error or anything else that does not have a .result prop, we assume it is not deployed\n          setIsDeployed(false)\n        }\n      })\n      .catch((err) => {\n        // as raw XHR calls, reverts are not caught, but only have .error prop\n        // this should be a netowrk error\n        setHasProviderError(err.message)\n      })\n  }, [account, requestedNetwork, fetch])\n\n  useEffect(() => {\n    checkIsDeployedAndHasPrivileges()\n  }, [checkIsDeployedAndHasPrivileges])\n\n  const handleSigningErr = useCallback(\n    (e: any) => {\n      if (e && e.message.includes('must provide an Ethereum address')) {\n        addToast(\n          `Signing error: not connected with the correct address. Make sure you're connected with ${account.signer?.address}.`,\n          { error: true }\n        )\n      } else {\n        addToast(`Signing error: ${e.message || e}`, {\n          error: true\n        })\n      }\n    },\n    [account, addToast]\n  )\n\n  const verifySignature = useCallback(\n    (toSign, sig, networkId) => {\n      const provider = getProvider(networkId)\n      return verifyMessage({\n        provider,\n        signer: account.id,\n        message: isTypedData ? null : getMessageAsBytes(toSign.txn),\n        typedData: isTypedData ? dataV4 : null,\n        signature: sig\n      })\n        .then((verificationResult: any) => {\n          if (verificationResult) {\n            addToast(`${toSign.type} SIGNATURE VALID`)\n          } else {\n            addToast(`${toSign.type} SIGNATURE INVALID`, { error: true })\n          }\n        })\n        .catch((e: any) => {\n          addToast(`${toSign.type} SIGNATURE INVALID: ${e.message}`, { error: true })\n        })\n    },\n    [account, addToast, dataV4, isTypedData]\n  )\n\n  const approveQuickAcc = useCallback(\n    async (credentials: any) => {\n      if (!relayerURL) {\n        addToast('Email/pass accounts not supported without a relayer connection', {\n          error: true\n        })\n        return\n      }\n      if (!credentials.password) {\n        addToast('Password required to unlock the account', { error: true })\n        return\n      }\n      setLoading(true)\n      try {\n        const { signature, success, message, confCodeRequired } = await fetchPost(\n          fetch,\n          // network doesn't matter when signing\n          // if it does tho, we can use ${network.id}\n          `${relayerURL}/second-key/${account.id}/ethereum/sign${\n            isTypedData ? '?typedData=true' : ''\n          }`,\n          {\n            toSign: toSign.txn,\n            code: credentials.code?.length ? credentials.code : undefined\n          }\n        )\n        if (!success) {\n          setLoading(false)\n          if (!message) throw new Error('Secondary key: no success but no error message')\n          if (message.includes('invalid confirmation code')) {\n            addToast('Unable to sign: wrong confirmation code', { error: true })\n          }\n          addToast(`Second signature error: ${message}`, {\n            error: true\n          })\n          setConfirmationType(null)\n          setLoading(false)\n\n          return\n        }\n        if (confCodeRequired) {\n          setConfirmationType(confCodeRequired)\n\n          if (onConfirmationCodeRequired) {\n            await onConfirmationCodeRequired(confCodeRequired, approveQuickAcc)\n          }\n\n          setLoading(false)\n          return\n        }\n\n        if (!account.primaryKeyBackup)\n          throw new Error(\n            'No key backup found: you need to import the account from JSON or login again.'\n          )\n        const wallet = await Wallet.fromEncryptedJson(\n          JSON.parse(account.primaryKeyBackup),\n          credentials.password\n        )\n        const sig = await (isTypedData\n          ? signMessage712(\n              wallet,\n              account.id,\n              account.signer,\n              dataV4.domain,\n              dataV4.types,\n              dataV4.message,\n              signature\n            )\n          : signMessage(\n              wallet,\n              account.id,\n              account.signer,\n              getMessageAsBytes(toSign.txn),\n              signature\n            ))\n\n        await verifySignature(toSign, sig, requestedNetwork?.id)\n\n        resolve({ success: true, result: sig })\n        addToast('Successfully signed!')\n        if (everythingToSign.length === 1) {\n          !!onLastMessageSign && onLastMessageSign()\n        }\n      } catch (e) {\n        handleSigningErr(e)\n      }\n      setLoading(false)\n    },\n    [\n      account,\n      addToast,\n      dataV4,\n      everythingToSign,\n      fetch,\n      handleSigningErr,\n      isTypedData,\n      onConfirmationCodeRequired,\n      onLastMessageSign,\n      relayerURL,\n      requestedNetwork,\n      resolve,\n      toSign,\n      verifySignature\n    ]\n  )\n  // Passing hardware device is required only for the mobile app\n  const approve = useCallback(\n    async (credentials: any, device?: any) => {\n      if (account.signer?.quickAccManager) {\n        await approveQuickAcc(credentials)\n        return\n      }\n      setLoading(true)\n\n      try {\n        const wallet = await getHardwareWallet(device)\n\n        if (!wallet) {\n          return\n        }\n\n        // It would be great if we could pass the full data cause then web3 wallets/hw wallets can display the full text\n        // Unfortunately that isn't possible, because isValidSignature only takes a bytes32 hash; so to sign this with\n        // a personal message, we need to be signing the hash itself as binary data such that we match 'Ethereum signed message:\\n32<hash binary data>' on the contract\n\n        const sig = await (toSign.type === 'eth_signTypedData_v4' ||\n        toSign.type === 'eth_signTypedData'\n          ? signMessage712(\n              wallet,\n              account.id,\n              account.signer,\n              dataV4.domain,\n              dataV4.types,\n              dataV4.message\n            )\n          : signMessage(wallet, account.id, account.signer, getMessageAsBytes(toSign.txn)))\n\n        await verifySignature(toSign, sig, requestedNetwork?.id)\n\n        resolve({ success: true, result: sig })\n        addToast('Successfully signed!')\n      } catch (e) {\n        handleSigningErr(e)\n      }\n      setLoading(false)\n    },\n    [\n      account,\n      addToast,\n      approveQuickAcc,\n      dataV4,\n      getHardwareWallet,\n      handleSigningErr,\n      requestedNetwork?.id,\n      resolve,\n      toSign,\n      verifySignature\n    ]\n  )\n\n  return {\n    approve,\n    approveQuickAcc,\n    toSign,\n    isLoading,\n    hasPrivileges,\n    hasProviderError,\n    typeDataErr,\n    isDeployed,\n    dataV4,\n    requestedNetwork,\n    requestedChainId,\n    isTypedData,\n    confirmationType\n  }\n}\n\nexport default useSignMessage\n","import networks from '../../constants/networks'\n\nexport const getNetworkByChainId = (chainId?: string | number) => {\n  if (!chainId) return null\n\n  return networks.find((n) => n.chainId === parseInt(chainId.toString(), 10))\n}\n\nexport const getNetworkById = (id: string | number) => {\n  return networks.find((n) => n.id === id)\n}\n","import useSignMessage from './useSignMessage'\n\nexport default useSignMessage\n","const { BN } = require('bn.js')\n\nfunction Uint256(x) {\n\tconst bn = new BN(x, 10)\n\tif (bn.isNeg()) throw new Error('uint256 expected, negative number given')\n\treturn bn\n}\n\nfunction Address(x) {\n\tif (!(typeof x === 'string' && x.length === 42 && x.startsWith('0x')))\n\t\tthrow new Error('invalid address: must start with a 0x and be 42 characters long')\n\treturn x\n}\n\nfunction Bytes32(b) {\n\tif (typeof b === 'string' && b.startsWith('0x') && b.length === 66) {\n\t\treturn Buffer.from(b.slice(2), 'hex')\n\t}\n\tif (!(b.length === 32 && Buffer.isBuffer(b))) throw new Error('32 byte Buffer expected')\n\treturn b\n}\n\nfunction Bytes(b) {\n\tif (typeof b === 'string' && b.startsWith('0x')) {\n\t\treturn Buffer.from(b.slice(2), 'hex')\n\t}\n\tif (!Buffer.isBuffer(b)) throw new Error('Buffer expected')\n\treturn b\n}\n\nfunction Bytes32Array(bytes32Array, size) {\n\t// no size specified\n\tif (size === -1 || size === undefined) {\n\t\treturn bytes32Array.map(x => Bytes32(x))\n\t}\n\treturn bytes32Array.length === size && bytes32Array.map(x => Bytes32(x))\n}\n\nfunction Channel(channel) {\n\tAddress(channel.leader)\n\tAddress(channel.follower)\n\tAddress(channel.guardian)\n\tAddress(channel.tokenAddr)\n\tBytes32(channel.nonce)\n\treturn channel\n}\n\nmodule.exports = { Uint256, Bytes32, Address, Bytes, Bytes32Array, Channel }\n","const { AbiCoder, hexlify, arrayify, keccak256, Interface } = require('ethers').utils\nconst { Contract, BigNumber } = require('ethers')\n\nconst ensure = require('./ensureTypes')\n\nconst IdentityABI = require('../abi/Identity5.2')\nconst QuickAccManagerABI = require('../abi/QuickAccManager')\n\nconst IdentityInterface = new Interface(IdentityABI)\n\nfunction Bundle(args) {\n\tthis.identity = ensure.Address(args.identity)\n\tthis.network = args.network\n\t// @TODO validate this\n\tthis.signer = args.signer\n\tthis.txns = args.txns\n\tthis.gasLimit = args.gasLimit\n\tthis.nonce = args.nonce\n\tthis.signature = args.signature\n\tthis.minFeeInUSDPerGas = args.minFeeInUSDPerGas\n\tthis.recoveryMode = args.recoveryMode\n\tthis.meta = args.meta\n\tthis.gasTankFee = args.gasTankFee\n\treturn this\n}\n\nBundle.prototype.getNonce = async function(provider) {\n\tthis.nonce = await getNonce(provider, this)\n\treturn this.nonce\n}\n\nBundle.prototype.estimate = async function({ fetch, relayerURL, replacing, getNextNonce, gasTank }) {\n\tconst queryParams = Object.fromEntries(Object.entries({getNextNonce, gasTank}).filter(([_, v]) => v))\n\tconst res = await fetchPost(\n\t\tfetch,\n\t\t`${relayerURL}/identity/${this.identity}/${this.network}/estimate?${\n\t\t\t(new URLSearchParams(queryParams)).toString()\n\t\t}`,\n\t\t{ txns: this.txns, signer: this.signer, replacing, minFeeInUSDPerGas: this.minFeeInUSDPerGas }\n\t)\n\tthis.gasLimit = res.gasLimit\n\treturn res\n}\n\nBundle.prototype.sign = async function(wallet, isSingleSigMode) {\n\tif (isNaN(this.nonce)) throw new Error('nonce is not set')\n\tif (isNaN(this.gasLimit)) throw new Error('gasLimit is not set')\n\tconst encoded = getSignable(this, isSingleSigMode)\n\tconst hash = arrayify(keccak256(encoded))\n\tconst signature = await signMsg(wallet, hash)\n\tthis.signature = signature\n\treturn signature\n}\n\nBundle.prototype.submit = async function({ fetch, relayerURL }) {\n\tconst res = await fetchPost(\n\t\tfetch,\n\t\t`${relayerURL}/identity/${this.identity}/${this.network}/submit`,\n\t\t{\n\t\t\tnonce: this.nonce,\n\t\t\tsigner: this.signer,\n\t\t\ttxns: this.txns,\n\t\t\tgasLimit: this.gasLimit,\n\t\t\tsignature: this.signature,\n\t\t\tsignatureTwo: this.signatureTwo,\n\t\t\tmeta: this.meta,\n\t\t\tgasTankFee: this.gasTankFee\n\t\t}\n\t)\n\treturn res\n}\n\nBundle.prototype.cancel = async function({ fetch, relayerURL }) {\n\tconst res = await fetchPost(\n\t\tfetch,\n\t\t`${relayerURL}/identity/${this.identity}/${this.network}/cancel`,\n\t\t{ nonce: this.nonce, signer: this.signer }\n\t)\n\treturn res\n}\n\nconst UNPREDICTABLE_GAS_REGEX = /gas required exceeds allowance|always failing transaction|execution reverted/\nBundle.prototype.estimateNoRelayer = async function({ provider, replacing }) {\n\tconst txParams = {\n\t\tfrom: this.signer.quickAccManager || this.signer.address,\n\t\tto: this.identity,\n\t\tdata: IdentityInterface.encodeFunctionData('executeBySender', [this.txns])\n\t}\n\tconst blockTag = replacing ? 'latest' : 'pending'\n\tconst { error, gasLimit } = await estimateGasWithCatch(provider, blockTag, txParams)\n\tif (error && error.message.startsWith('execution reverted: ')) {\n\t\tconst message = error.message.slice(20)\n\t\treturn { success: false, message }\n\t}\n\tif (error) {\n\t\t// Match both the code and the regex to handle both errs from ethers and raw ones from nodes in case we use .send\n\t\tif (!(error.code === 'UNPREDICTABLE_GAS_LIMIT' || error.message.match(UNPREDICTABLE_GAS_REGEX)))\n\t\t\tthrow error\n\t\treturn { success: false, message: await getErrMsg(provider, txParams, blockTag) }\n\t}\n\tthis.gasLimit = gasLimit.toNumber()\n\t// @TODO EIP1559-optimized estimations (good first issue for external contributors)\n\tconst feeData = await provider.getFeeData()\n\tconst gasPrice = feeData.gasPrice.toNumber()\n\tconst baseFee = (gasPrice * gasLimit) / 1e18\n\treturn {\n\t\tsuccess: true,\n\t\tgasLimit: this.gasLimit,\n\t\tgasPrice,\n\t\tfeeInNative: {\n\t\t\tslow: baseFee * 0.9,\n\t\t\tmedium: baseFee * 1.0,\n\t\t\tfast: baseFee * 1.15,\n\t\t\tape: baseFee * 1.4\n\t\t}\n\t}\n}\n\nasync function signMessage(wallet, identity, signer, message, signatureTwo) {\n\tif (signer.address) return signMsg(wallet, message, true)\n\tif (signer.quickAccManager) {\n\t\tconst signatureOne = await signMsg(wallet, message, true)\n\t\t// the inner sig is the one that the QuickAccManager interprets by doing an abi.decode and sending each individual signature to isValidSignature\n\t\tconst abiCoder = new AbiCoder()\n\t\tconst sigInner = abiCoder.encode(\n\t\t\t['uint', 'bytes', 'bytes'],\n\t\t\t[signer.timelock, signatureOne, signatureTwo]\n\t\t)\n\t\t// 02 is the SmartWallet type sig; we're essentially formatting this as a smart wallet type sig, verified by the quickAccManager\n\t\tconst sig = `${sigInner + abiCoder.encode(['address'], [signer.quickAccManager]).slice(2)}02`\n\t\treturn sig\n\t}\n\tthrow new Error(`invalid signer object`)\n}\n\n\nasync function signMessage712(wallet, identity, signer, domain, types, value, signatureTwo) {\n\tif (signer.address) return signMsg712(wallet, domain, types, value)\n\tif (signer.quickAccManager) {\n\t\tconst signatureOne = await signMsg712(wallet, domain, types, value)\n\t\t// the inner sig is the one that the QuickAccManager interprets by doing an abi.decode and sending each individual signature to isValidSignature\n\t\tconst abiCoder = new AbiCoder()\n\t\tconst sigInner = abiCoder.encode(\n\t\t\t['uint', 'bytes', 'bytes'],\n\t\t\t[signer.timelock, signatureOne, signatureTwo]\n\t\t)\n\t\t// 02 is the SmartWallet type sig; we're essentially formatting this as a smart wallet type sig, verified by the quickAccManager\n\t\tconst sig = `${sigInner + abiCoder.encode(['address'], [signer.quickAccManager]).slice(2)}02`\n\t\treturn sig\n\t}\n\tthrow new Error(`invalid signer object`)\n}\n\nfunction getSignable(userTxnBundle, isSingleSigMode) {\n\tconst abiCoder = new AbiCoder()\n\tconst signer = userTxnBundle.signer\n\tif (signer.address)\n\t\treturn abiCoder.encode(\n\t\t\t['address', 'uint', 'uint', 'tuple(address, uint, bytes)[]'],\n\t\t\t[\n\t\t\t\tuserTxnBundle.identity,\n\t\t\t\tgetChainID(userTxnBundle.network),\n\t\t\t\tuserTxnBundle.nonce,\n\t\t\t\tuserTxnBundle.txns\n\t\t\t]\n\t\t)\n\tif (signer.quickAccManager) {\n\t\tconst accHash = keccak256(\n\t\t\tabiCoder.encode(\n\t\t\t\t['tuple(uint, address, address)'],\n\t\t\t\t[[userTxnBundle.signer.timelock, userTxnBundle.signer.one, userTxnBundle.signer.two]]\n\t\t\t)\n\t\t)\n\t\t// @TODO typed data\n\t\t// if (signer.isTypedData)\n\t\treturn abiCoder.encode(\n\t\t\t['address', 'uint', 'address', 'bytes32', 'uint', 'tuple(address, uint, bytes)[]', 'bool'],\n\t\t\t[\n\t\t\t\tsigner.quickAccManager,\n\t\t\t\tgetChainID(userTxnBundle.network),\n\t\t\t\tuserTxnBundle.identity,\n\t\t\t\taccHash,\n\t\t\t\tuserTxnBundle.nonce,\n\t\t\t\tuserTxnBundle.txns,\n\t\t\t\t!isSingleSigMode\n\t\t\t]\n\t\t)\n\t}\n\tthrow new Error(`invalid signer object`)\n}\n\nfunction getChainID(network) {\n\tif (network === 'ethereum') return 1\n\tif (network === 'polygon') return 137\n\tif (network === 'binance-smart-chain') return 56\n\tif (network === 'bsc') return 56\n\tif (network === 'fantom') return 250\n\tif (network === 'avalanche') return 43114\n\tif (network === 'arbitrum') return 42161\n\tif (network === 'moonbeam') return 1284\n\tif (network === 'moonriver') return 1285\n\tif (network === 'gnosis') return 100\n\tif (network === 'kucoin') return 321\n\tif (network === 'andromeda') return 1088\n\tif (network === 'cronos') return 25\n\tif (network === 'aurora') return 1313161554\n\tif (network === 'rinkeby') return 4\n\tif (network === 'optimism') return 10\n\tthrow new Error(`unsupported network ${network}`)\n}\n\nfunction mapSignatureV(sigRaw) {\n\tconst sig = arrayify(sigRaw)\n\tif (sig[64] < 27) sig[64] += 27\n\treturn hexlify(sig)\n}\n\nasync function signMsg(wallet, message, useFinalDigestSigMode = false) {\n\t// assert.equal(hash.length, 32, 'hash must be 32byte array buffer')\n\t// was 01 originally but to avoid prefixing in solidity, we changed it to 00\n\treturn `${mapSignatureV(await wallet.signMessage(message))}${useFinalDigestSigMode ? '00' : '01'}`\n}\n\nasync function signMsg712(wallet, domain, types, value) {\n\t// 00 is the enum number of SignatureMode.EIP712\n\tconst typedDataSign = await wallet._signTypedData(domain, types, value)\n\treturn `${mapSignatureV(typedDataSign)}00`\n}\n\nasync function getNonce(provider, userTxnBundle) {\n\ttry {\n\t\treturn (userTxnBundle.signer.quickAccManager\n\t\t\t? await new Contract(\n\t\t\t\t\tuserTxnBundle.signer.quickAccManager,\n\t\t\t\t\tQuickAccManagerABI,\n\t\t\t\t\tprovider\n\t\t\t  ).nonces(userTxnBundle.identity)\n\t\t\t: await new Contract(userTxnBundle.identity, IdentityABI, provider).nonce()\n\t\t).toNumber()\n\t} catch (e) {\n\t\t// means the identity isn't deployed, which certainly implies nonce 0\n\t\tif (e.code === 'CALL_EXCEPTION' && (await provider.getCode(userTxnBundle.identity)) === '0x')\n\t\t\treturn 0\n\t\tthrow e\n\t}\n}\n\nasync function fetchPost(fetch, url, body) {\n\tconst r = await fetch(url, {\n\t\theaders: { 'content-type': 'application/json' },\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify(body)\n\t})\n\treturn r.json()\n}\n\n// helpers for estimateNoRelayer\n\n// Signature of Error(string)\nconst ERROR_SIG = '0x08c379a0'\n\nasync function getErrMsg(provider, txParams, blockTag) {\n\t// .call always returns a hex string with ethers\n\ttry {\n\t\tconst returnData = await provider.call(txParams, blockTag)\n\t\treturn returnData.startsWith(ERROR_SIG)\n\t\t\t? new AbiCoder().decode(['string'], `0x${returnData.slice(10)}`)[0]\n\t\t\t: returnData\n\t} catch (e) {\n\t\t// weird infura case\n\t\tif (e.code === 'UNPREDICTABLE_GAS_LIMIT' && e.error) return e.error.message.slice(20)\n\t\tif (e.code === 'CALL_EXCEPTION') return 'no error string, possibly insufficient amount'\n\t\tif (e.code === 'INVALID_ARGUMENT') return `unable to deserialize: ${hexlify(e.value)}`\n\t\tthrow e\n\t}\n}\n\nasync function estimateGasWithCatch(provider, blockTag, tx) {\n\treturn (\n\t\tprovider\n\t\t\t.send('eth_estimateGas', [tx, blockTag])\n\t\t\t.then(gasLimit => ({ gasLimit: BigNumber.from(gasLimit) }))\n\t\t\t// with .send, the error is wrapped in another error\n\t\t\t.catch(e => (e.code === 'SERVER_ERROR' ? { error: e.error } : { error: e }))\n\t)\n}\n\n// getNonce(require('ethers').getDefaultProvider('homestead'), { identity: '0x23c2c34f38ce66ccc10e71e9bb2a06532d52c5e8', signer: {address: '0x942f9CE5D9a33a82F88D233AEb3292E680230348'}, txns: [] }).then(console.log)\n\nmodule.exports = { Bundle, signMessage, signMessage712, getSignable, signMsg, signMsg712 }\n"],"sourceRoot":""}