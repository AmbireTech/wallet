{"version":3,"sources":["lib/lattice.js","lib/getWallet.js","lib/ledgerWebHID.js"],"names":["crypto","require","HARDENED_OFFSET","getAddressesReqOpts","startPath","n","latticeInit","commKey","clientConfig","name","privKey","Client","latticeConnect","client","deviceId","a","Promise","resolve","reject","connect","err","isPaired","errConnect","catch","console","error","latticePair","secret","pair","hasActiveWallet","errPair","latticeGetAddresses","getAddresses","res","Error","errGetAddresses","latticeSignMessage","hash","dataMsg","protocol","payload","ethers","utils","hexlify","signerPath","signOptsMsg","currency","data","sign","signedTx","signedMsg","sig","r","s","v","toString","errSignMessage","latticeSignMessage712","message","reqData","latticeSignTransaction","txn","chainId","to","gas","gasPrice","nonce","value","unsignedTxObj","gasLimit","from","txData","useEIP155","signOpts","serializedSigned","serialize","errSignTxn","wallets","getWallet","signer","signerExtra","opts","id","address","one","getWalletNew","type","providerTrezor","TrezorSubprovider","trezorConnectClientApi","TrezorConnect","networkId","_initialDerivedKeyInfo","hdKey","HDNode","fromExtendedKey","info","xpub","derivationPath","baseDerivationPath","getInitialDerivedKeyInfo","signMessage","signPersonalMessageAsync","signTransaction","params","signTransactionAsync","sendTransaction","transaction","network","networks","find","getProvider","broadcastProvider","getTransactionCount","isConnected","matchAddress","getAccountsAsync","addresses","map","i","toLowerCase","includes","_signTypedData","domain","types","domainSeparator","_TypedDataEncoder","hashDomain","hashStructMessage","hashStruct","getPrimaryType","getPayload","_initialDerivedKeyInfoAsync","initialDerivedKeyInfo","derivedKeyInfo","_findDerivedKeyInfoForAddress","path","_trezorConnectClientApi","ethereumSignTypedData","metamask_v4_compat","domain_separator_hash","message_hash","response","success","signature","transportProtocol","ledgerSignMessage","ledgerSignTransaction","provider","ledgerGetAddresses","ledgerSignMessage712","LedgerSubprovider","ledgerEthereumClientFactoryAsync","ledgerEthereumBrowserClientFactoryAsync","wrapLatticeError","window","ethereum","providers","Web3Provider","signerObject","getSigner","matchChain","listAccounts","accounts","match","length","getNetwork","fn","arg","apply","this","e","ethUtil","connectedDevices","PARENT_HD_PATH","getTransport","TransportWebHID","list","opened","open","request","transport","getAccounts","close","parentKeyDerivationPath","getAddressInternal","then","o","statusCode","ledgerResponse","publicKey","Buffer","chainCode","mainAddress","addressOfHDKey","calculateDerivedHDKeyInfos","appEth","AppEth","ledgerTimeout","timeoutHandle","setTimeout","race","getAddress","clearTimeout","fromAddr","serializedUnsigned","accountsData","substr","rsvResponse","intV","parseInt","Math","floor","signerAddress","account","signPersonalMessage","rsvReply","signEIP712HashedMessage","count","derivedKeys","fullDerivationPath","derive","derivedKey","push","derivedPublicKey","ethereumAddressUnprefixed","publicToAddress","addHexPrefix"],"mappings":"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","file":"static/js/5.c43e763a.chunk.js","sourcesContent":["import { Client } from 'gridplus-sdk'\nimport { ethers } from 'ethers'\nimport { serialize } from '@ethersproject/transactions'\n\nconst crypto = require('crypto')\nconst HARDENED_OFFSET = 0x80000000\n\nconst getAddressesReqOpts = {\n    startPath: [\n        HARDENED_OFFSET + 44,\n        HARDENED_OFFSET + 60,\n        HARDENED_OFFSET,\n        0,\n        0,\n    ],\n    n: 10,\n}\n\nconst latticeInit = commKey => {\n    const clientConfig = {\n        name: 'Ambire Wallet',\n        crypto: crypto,\n        privKey: commKey,\n    }\n\n    return new Client(clientConfig)\n}\n\nconst latticeConnect = async(client, deviceId) => {\n    return await new Promise((resolve, reject) => {\n        client.connect(deviceId, (err, isPaired) => {\n            if (err) {\n                reject(`Lattice connect: ${err} Or check if the DeviceID is correct.`)\n                return\n            }\n            \n            resolve({ isPaired: !!isPaired, errConnect: false })\n        })\n    }).catch(err => {\n        console.error(err)\n        return { isPaired: false, errConnect: err }\n    })\n}\n\nconst latticePair = async(client, secret) => {\n    return await new Promise((resolve, reject) => {\n        client.pair(secret, (err, hasActiveWallet) => {\n            if (err) {\n                reject(`Lattice connect: ${err}`)\n                return\n            }\n            \n            resolve({ hasActiveWallet, errPair: false })\n        })\n    }).catch(err => {\n        console.error(err)\n        return { hasActiveWallet: false, errPair: err }\n    })\n}\n\nconst latticeGetAddresses = async client => {\n    return await new Promise((resolve, reject) => {\n        client.getAddresses(getAddressesReqOpts, (err, res) => {\n            if (err) {\n                reject(`Lattice get addresses: ${err}`)\n                return\n            }\n\n            if (!res) throw new Error('Lattice could not get the addresses.')\n\n            resolve({res, errGetAddresses: false })\n        })\n    }).catch(err => {\n        console.error(err)\n        return { res: null, errGetAddresses: err }\n    })\n}\n\nconst latticeSignMessage = async(client, hash) => {\n    const dataMsg = {\n        protocol: 'signPersonal',\n        payload: ethers.utils.hexlify(hash),\n        signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, 0],\n    }\n\n    const signOptsMsg = {\n        currency: 'ETH_MSG',\n        data: dataMsg,\n    }\n\n    \n    return await new Promise((resolve, reject) => {\n        client.sign(signOptsMsg, (err, signedTx) => {\n            if (err) {\n                reject(err)\n                return\n            }\n\n            if (!signedTx) throw new Error('Lattice could not sign the message.')\n            \n            resolve({ signedMsg: '0x' + signedTx.sig.r + signedTx.sig.s + signedTx.sig.v[0].toString(16), errSignMessage: false })  \n        })\n    }).catch(err => {\n        console.error(err)\n        return { signedMsg: null, errSignMessage: err }\n    })\n}\n\nconst latticeSignMessage712 = async(client, message) => {\n    const reqData = {\n        currency: 'ETH_MSG',\n        data: {\n          signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, 0],\n          protocol: 'eip712', // You must use this string to specify this protocol\n          payload: message\n        }\n      }\n\n    return await new Promise((resolve, reject) => {\n        client.sign(reqData, (err, signedTx) => {\n            if (err) {\n                reject(err)\n                return\n            }\n\n            if (!signedTx) throw new Error('Lattice could not sign the message.')\n            \n            resolve({ signedMsg: '0x' + signedTx.sig.r + signedTx.sig.s + signedTx.sig.v[0].toString(16), errSignMessage: false })  \n        })\n    }).catch(err => {\n        console.error(err)\n        return { signedMsg: null, errSignMessage: err }\n    })\n}\n\nconst latticeSignTransaction = async(client, txn, chainId) => {\n    const { to, data, gas, gasPrice, nonce, value = 0 } = txn\n    const unsignedTxObj = {\n        ...txn,\n        gasLimit: txn.gasLimit || txn.gas,\n        chainId\n    }\n    delete unsignedTxObj.from\n    delete unsignedTxObj.gas\n\n    const txData = {\n        nonce,\n        gasLimit: gas || txn.gasLimit,\n        gasPrice,\n        to,\n        value,\n        data: data || '',\n        // -- m/44'/60'/0'/0/0\n        signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, 0],\n        chainId,\n        useEIP155: true,\n    }\n\n    const signOpts = {\n        currency: 'ETH',\n        data: txData,\n    }\n\n    \n    return await new Promise((resolve, reject) => {\n        client.sign(signOpts, (err, signedTx) => {\n            if (err) {\n                reject(err)\n                return\n            }\n\n            if (!signedTx) throw new Error('Lattice could not sign the message.')\n            \n            delete unsignedTxObj.v\n            const serializedSigned = serialize(unsignedTxObj, {\n                r: '0x' + signedTx.sig.r,\n                s: '0x' + signedTx.sig.s,\n                v: signedTx.sig.v[0].toString(16)\n            })\n            \n            resolve({ serializedSigned, errSignTxn: false })\n        })\n    }).catch(err => {\n        console.error(err)\n        return { serializedSigned: null, errSignTxn: err }\n    })\n}\n\nexport { \n    latticeInit,\n    latticeConnect,\n    latticePair,\n    latticeGetAddresses,\n    latticeSignMessage,\n    latticeSignMessage712,\n    latticeSignTransaction\n }\n","import { TrezorSubprovider } from '@0x/subproviders/lib/src/subproviders/trezor' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport TrezorConnect from '@trezor/connect-web'\nimport { ethers } from 'ethers'\nimport HDNode from 'hdkey'\nimport { LedgerSubprovider } from '@0x/subproviders/lib/src/subproviders/ledger' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport { ledgerEthereumBrowserClientFactoryAsync } from '@0x/subproviders/lib/src' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport { ledgerSignMessage, ledgerSignTransaction, ledgerSignMessage712, ledgerGetAddresses } from './ledgerWebHID'\nimport { \n  latticeInit, \n  latticeConnect, \n  latticeSignMessage, \n  latticeSignTransaction, \n  latticeGetAddresses, \n  latticeSignMessage712\n } from 'lib/lattice'\nimport { _TypedDataEncoder } from 'ethers/lib/utils'\nimport { getProvider } from 'lib/provider'\nimport networks from 'consts/networks'\n\nlet wallets = {}\n\n// opts\n// passphrase: string\n// noCache: boolean\nexport function getWallet({ signer, signerExtra, chainId }, opts = {}) {\n  const id = `${signer.address || signer.one}${chainId}`\n  if (wallets[id]) return wallets[id]\n  return wallets[id] = getWalletNew({ signer, signerExtra, chainId }, opts)\n}\n\nfunction getWalletNew({ chainId, signer, signerExtra }, opts) {\n  if (signerExtra && signerExtra.type === 'trezor') {\n    const providerTrezor = new TrezorSubprovider({\n      trezorConnectClientApi: TrezorConnect,\n      networkId: chainId\n    })\n    providerTrezor._initialDerivedKeyInfo = getInitialDerivedKeyInfo(signerExtra)\n    // for Trezor/ledger, alternatively we can shim using https://www.npmjs.com/package/web3-provider-engine and then wrap in Web3Provider\n    return {\n      signMessage: hash => providerTrezor.signPersonalMessageAsync(ethers.utils.hexlify(hash), signer.address),\n      signTransaction: params => providerTrezor.signTransactionAsync({ ...params, from: signer.address }),\n      sendTransaction: async (transaction) => {\n        const network = networks.find(n => n.chainId === transaction.chainId)\n        if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n        const broadcastProvider = await getProvider(network.id)\n        if (!broadcastProvider) throw Error('no provider found for network : ' + network.id)\n\n        transaction.nonce = ethers.utils.hexlify(await broadcastProvider.getTransactionCount(transaction.from))\n        const gas = ethers.utils.hexlify(transaction.gas || transaction.gasLimit)\n        transaction.gasPrice = ethers.utils.hexlify(transaction.gasPrice)\n        \n        transaction = {\n          ...transaction,\n          gas // trezor params requires gas prop\n          // no chainId prop but chainId already known by providerTrezor\n        }\n        \n        const signedTx = await providerTrezor.signTransactionAsync(transaction)\n        \n        return broadcastProvider.sendTransaction(signedTx)\n      },\n      isConnected: async (matchAddress) => { // chain is provided to trezor. Not necessary to check network\n        const addresses = await providerTrezor.getAccountsAsync(100)\n        return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n      },\n      _signTypedData: async (domain, types, value) => {\n        \n        const domainSeparator = _TypedDataEncoder.hashDomain(domain)\n        const hashStructMessage = _TypedDataEncoder.hashStruct(_TypedDataEncoder.getPrimaryType(types), types, value)\n        const data = _TypedDataEncoder.getPayload(domain, types, value)\n        const initialDerivedKeyInfo = await providerTrezor._initialDerivedKeyInfoAsync()\n        const derivedKeyInfo = providerTrezor._findDerivedKeyInfoForAddress(initialDerivedKeyInfo, signer.address)\n        const path = derivedKeyInfo.derivationPath\n\n        const response = await providerTrezor._trezorConnectClientApi.ethereumSignTypedData({\n          path,\n          data,\n          metamask_v4_compat: true,\n          domain_separator_hash: domainSeparator,\n          message_hash: hashStructMessage\n        })\n\n        if (response.success) {\n          return `${response.payload.signature}`;\n        } else {\n            throw new Error(response.payload.error);\n        }\n      }\n    }\n  } else if (signerExtra && signerExtra.type === 'ledger') {\n    if (signerExtra.transportProtocol === 'webHID') {\n      return {\n        signMessage: hash => ledgerSignMessage(ethers.utils.hexlify(hash), signer.address),\n        signTransaction: params => ledgerSignTransaction(params, chainId),\n        sendTransaction: async (transaction) => {\n          const network = networks.find(n => n.chainId === transaction.chainId)\n          if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n          const provider = await getProvider(network.id)\n          if (!provider) throw Error('no provider found for network : ' + network.id)\n\n          transaction.nonce = ethers.utils.hexlify(await provider.getTransactionCount(transaction.from))\n\n          const signedTx = await ledgerSignTransaction(transaction, transaction.chainId)\n\n          return provider.sendTransaction(signedTx)\n        },\n        isConnected: async (matchAddress) => { // chain is provided to ledger. Not necessary to check network\n          const addresses = await ledgerGetAddresses()\n          if (addresses && addresses[0]) {\n            if (matchAddress) {\n              return !!addresses.find(a => a.toLowerCase() === matchAddress.toLowerCase())\n            }\n            return true\n          }\n          return false\n        },\n        _signTypedData: (domain, types, value) => {\n          const domainSeparator = _TypedDataEncoder.hashDomain(domain)\n          const hashStructMessage = _TypedDataEncoder.hashStruct(_TypedDataEncoder.getPrimaryType(types), types, value)\n          return ledgerSignMessage712(domainSeparator, hashStructMessage, signer.address)\n        }\n      }\n    } else {\n      const provider = new LedgerSubprovider({\n        networkId: chainId,\n        ledgerEthereumClientFactoryAsync: ledgerEthereumBrowserClientFactoryAsync,\n        baseDerivationPath: signerExtra.info.baseDerivationPath\n      })\n      return {\n        signMessage: hash => provider.signPersonalMessageAsync(ethers.utils.hexlify(hash), signer.address),\n        signTransaction: params => provider.signTransactionAsync({ ...params, from: signer.address }),\n        sendTransaction: async () => {\n          throw Error('Please use a chrome based browser to use Ledger')\n        },\n        isConnected: async (matchAddress) => { // chain is provided to ledger. Not necessary to check network\n          const addresses = await provider.getAccountsAsync(1)\n          return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n        },\n        _signTypedData: (domain, types, value) => {\n          throw Error('Please, use a chrome based browser to use 721 Typed signatures')\n        }\n      }\n    }\n  } else if (signerExtra && signerExtra.type === 'Lattice') {\n    return {\n      signMessage: async hash => {\n        return await wrapLatticeError(async hash => {\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { signedMsg, errSignMessage } = await latticeSignMessage(client, hash)\n          if (errSignMessage) throw new Error(errSignMessage)\n\n          return signedMsg\n        }, [hash])\n      },\n      signTransaction: async params => {\n        return await wrapLatticeError( async params => {\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { serializedSigned, errSignTxn } = await latticeSignTransaction(client, params, chainId)\n          if (errSignTxn) throw new Error(errSignTxn)\n\n          return serializedSigned\n        }, [params])\n      },\n      sendTransaction: async transaction => { \n        return await wrapLatticeError(async (transaction) => {\n          const network = networks.find(n => n.chainId === transaction.chainId)\n          if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n          const broadcastProvider = await getProvider(network.id)\n          if (!broadcastProvider) throw Error('no provider found for network : ' + network.id)\n          transaction.nonce = ethers.utils.hexlify(await broadcastProvider.getTransactionCount(transaction.from))\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const { isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { serializedSigned, errSignTxn } = await latticeSignTransaction(client, transaction, chainId)\n          if (errSignTxn) throw new Error(errSignTxn)\n\n          return broadcastProvider.sendTransaction(serializedSigned)\n        }, [transaction])\n      },\n      isConnected: async matchAddress => { \n        return await wrapLatticeError(async (matchAddress) => {\n          let addresses = null\n\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const { isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { res, errGetAddresses } = await latticeGetAddresses(client)\n          if (errGetAddresses) { \n            throw new Error(`Lattice: ${errGetAddresses}`, { error: true })\n          }\n\n          addresses = res\n          return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n        }, [matchAddress])\n    },\n    _signTypedData: async (domain, types, value) => {\n      return await wrapLatticeError(async (domain, types, value) => {\n        const payload = _TypedDataEncoder.getPayload(domain, types, value)\n        const { commKey, deviceId } = signerExtra\n        const client = latticeInit(commKey)\n        const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n        if (errConnect) throw new Error(errConnect.message || errConnect)\n\n        if (!isPaired) {\n          // Canceling the visualization of the secret code on the device's screen.\n          client.pair('')\n          throw new Error('The Lattice device is not paired! Please re-add your account!')\n        }\n\n        const { signedMsg, errSignMessage } = await latticeSignMessage712(client, payload)\n        if (errSignMessage) throw new Error(errSignMessage)\n\n        return signedMsg\n      }, [domain, types, value])\n    }\n  }\n  } else if (signer.address) {\n    if (!window.ethereum) throw new Error('No web3 support detected in your browser: if you created this account through MetaMask, please install it.')\n    // NOTE: for metamask, use `const provider = new ethers.providers.Web3Provider(window.ethereum)`\n    // 'any' is explained here: https://github.com/ethers-io/ethers.js/issues/1107\n    const provider = new ethers.providers.Web3Provider(window.ethereum, 'any')\n\n    const signerObject = provider.getSigner(signer.address)\n\n    signerObject.isConnected = async (matchAddress, matchChain) => {\n      const accounts = await provider.listAccounts()\n\n      let match = true\n      if (!!(accounts.length)) {\n        if (matchAddress) {\n          match = !!accounts.find(a => a.toLowerCase() === matchAddress.toLowerCase())\n        }\n        if (matchChain) {\n          const { chainId } = await provider.getNetwork()\n          match = match && chainId === matchChain\n        }\n      } else {\n        match = false\n      }\n      return match\n    }\n\n    return signerObject\n  } else if (signer.one) {\n    throw new Error('getWallet not applicable for QuickAccounts: use primaryKeyBackup with the passphrase and /second-sig')\n  } else {\n    throw new Error('unknown signer type')\n  }\n}\n\nfunction getInitialDerivedKeyInfo(signerExtra) {\n  return {\n    hdKey: HDNode.fromExtendedKey(signerExtra.info.hdKey.xpub),\n    derivationPath: signerExtra.info.derivationPath,\n    baseDerivationPath: signerExtra.info.baseDerivationPath\n  }\n}\n\nasync function wrapLatticeError(fn, arg) {\n  return await fn.apply(this, arg)\n   .catch(e => {\n     throw new Error(`Lattice: ${e.message}`)\n    })\n}\n","import TransportWebHID from '@ledgerhq/hw-transport-webhid'\nimport AppEth from '@ledgerhq/hw-app-eth'\nimport { serialize } from '@ethersproject/transactions'\n\nconst EIP_155_CONSTANT = 35\n\nconst ethUtil = require('ethereumjs-util')\nconst HDNode = require('hdkey')\n\nlet connectedDevices = null\n\nexport const PARENT_HD_PATH = \"44'/60'/0'/0\"\n\nasync function getTransport() {\n  connectedDevices = await TransportWebHID.list()\n  if (connectedDevices.length) {\n    if (connectedDevices[0].opened) {\n      return new TransportWebHID(connectedDevices[0])\n    } else { // when transport is still not closed and time between 2 requests is short\n      return TransportWebHID.open(connectedDevices[0])\n    }\n  } else {\n    try {\n      return await TransportWebHID.request()\n    } catch (e) {\n      if (e.message.includes('reading \\'open\\'')) {\n        throw new Error('ledger WebHID request denied')\n      }\n      throw new Error('Could not request WebHID ledger: ' + e.message)\n    }\n  }\n}\n\nexport async function ledgerGetAddresses() {\n  const transport = await getTransport()\n  const accounts = await getAccounts(transport)\n  transport.close()\n\n  return accounts.map(a => a.address)\n}\n\nasync function getAccounts(transport) {\n  const parentKeyDerivationPath = `m/${PARENT_HD_PATH}`\n  let ledgerResponse\n  ledgerResponse = await getAddressInternal(transport, parentKeyDerivationPath).then(o => o).catch(err => {\n    if (err.statusCode === 25871 || err.statusCode === 27404) {\n      throw Error('Please make sure your ledger is unlocked and running the Ethereum app. ' + err.message)\n    } else {\n      throw Error('Could not get address from ledger : ' + err)\n    }\n  })\n\n  const hdKey = new HDNode()\n  hdKey.publicKey = Buffer.from(ledgerResponse.publicKey, 'hex')\n  hdKey.chainCode = Buffer.from(ledgerResponse.chainCode, 'hex')\n  const mainAddress = addressOfHDKey(hdKey)\n\n  const initialDerivedKeyInfo = {\n    hdKey,\n    address: mainAddress,\n    derivationPath: parentKeyDerivationPath,\n    baseDerivationPath: PARENT_HD_PATH,\n  }\n\n  // currently we can't get addrs to match with what appears in MM/Ledger live so only one is derived\n  return calculateDerivedHDKeyInfos(initialDerivedKeyInfo, 1)\n}\n\n\nasync function getAddressInternal(transport, parentKeyDerivationPath) {\n  let timeoutHandle\n  const appEth = new AppEth(transport)\n\n  const ledgerTimeout = new Promise((resolve, reject) => {\n    timeoutHandle = setTimeout(() => {\n      return reject(new Error('Device took too long to respond...'))\n    }, 10000)\n  })\n\n  return Promise.race([\n    appEth.getAddress(parentKeyDerivationPath, false, true),\n    ledgerTimeout\n  ]).then((res) => {\n    clearTimeout(timeoutHandle)\n    return res\n  })\n}\n\nexport async function ledgerSignTransaction(txn, chainId) {\n  const transport = await getTransport()\n\n  const fromAddr = txn.from\n\n  const unsignedTxObj = {\n    ...txn,\n    gasLimit: txn.gasLimit || txn.gas,\n    chainId: chainId\n  }\n  delete unsignedTxObj.from\n  delete unsignedTxObj.gas\n\n  let serializedUnsigned = serialize(unsignedTxObj)\n  const accountsData = await getAccounts(transport)\n\n  //Managing only 1 addr for now\n  const address = accountsData[0].address\n\n  let serializedSigned\n  if (address.toLowerCase() === fromAddr.toLowerCase()) {\n    let rsvResponse\n    try {\n      rsvResponse = await new AppEth(transport).signTransaction(accountsData[0].derivationPath, serializedUnsigned.substr(2))\n    } catch (e) {\n      throw new Error('Could not sign transaction ' + e)\n    }\n\n    const intV = parseInt(rsvResponse.v, 16)\n    const signedChainId = Math.floor((intV - EIP_155_CONSTANT) / 2)\n\n    if (signedChainId !== chainId) {\n      throw new Error('Invalid returned V 0x' + rsvResponse.v)\n    }\n\n    delete unsignedTxObj.v\n    serializedSigned = serialize(unsignedTxObj, {\n      r: '0x' + rsvResponse.r,\n      s: '0x' + rsvResponse.s,\n      v: intV\n    })\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n\n  transport.close()\n\n  return serializedSigned\n}\n\nexport async function ledgerSignMessage(hash, signerAddress) {\n  const transport = await getTransport()\n\n  const accountsData = await getAccounts(transport)\n\n  //TODO for multiple accs?\n  const account = accountsData[0]\n\n  let signedMsg\n  if (account.address.toLowerCase() === signerAddress.toLowerCase()) {\n    try {\n      const rsvReply = await new AppEth(transport).signPersonalMessage(account.derivationPath, hash.substr(2))\n      signedMsg = '0x' + rsvReply.r + rsvReply.s + rsvReply.v.toString(16)\n    } catch (e) {\n      throw new Error('Signature denied ' + e.message)\n    }\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n  transport.close()\n  return signedMsg\n}\n\nexport async function ledgerSignMessage712(domainSeparator, hashStructMessage, signerAddress) {\n  const transport = await getTransport()\n\n  const accountsData = await getAccounts(transport)\n\n  //TODO for multiple accs?\n  const account = accountsData[0]\n\n  let signedMsg\n  if (account.address.toLowerCase() === signerAddress.toLowerCase()) {\n    try {\n      const rsvReply = await new AppEth(transport).signEIP712HashedMessage(account.derivationPath, domainSeparator, hashStructMessage)\n      signedMsg = '0x' + rsvReply.r + rsvReply.s + rsvReply.v.toString(16)\n    } catch (e) {\n      throw new Error('Signature denied ' + e.message)\n    }\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n  transport.close()\n  return signedMsg\n}\n\nfunction calculateDerivedHDKeyInfos(initialDerivedKeyInfo, count) {\n  const derivedKeys = []\n  for (let i = 0; i < count; i++) {\n\n    const fullDerivationPath = `m/${initialDerivedKeyInfo.baseDerivationPath}/${i}`\n    const path = `m/${i}`\n    const hdKey = initialDerivedKeyInfo.hdKey.derive(path)\n    const address = addressOfHDKey(hdKey)\n    const derivedKey = {\n      address,\n      hdKey,\n      baseDerivationPath: initialDerivedKeyInfo.baseDerivationPath,\n      derivationPath: fullDerivationPath,\n    }\n\n    derivedKeys.push(derivedKey)\n  }\n  return derivedKeys\n}\n\nexport function addressOfHDKey(hdKey) {\n  const shouldSanitizePublicKey = true\n  const derivedPublicKey = hdKey.publicKey\n  const ethereumAddressUnprefixed = ethUtil\n    .publicToAddress(derivedPublicKey, shouldSanitizePublicKey)\n    .toString('hex')\n  return ethUtil.addHexPrefix(ethereumAddressUnprefixed).toLowerCase()\n}\n"],"sourceRoot":""}