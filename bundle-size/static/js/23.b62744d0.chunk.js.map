{"version":3,"sources":["../node_modules/@ambire/signature-validator/index.js","../node_modules/ambire-common/src/hooks/useSignMessage/useSignMessage.ts","../node_modules/ambire-common/src/services/getNetwork/getNetwork.ts","../node_modules/ambire-common/src/hooks/useSignMessage/index.ts","../node_modules/ambire-common/src/constants/supportedDApps.ts","components/SignMessage/SignMessage.js"],"names":["ethers","require","VALIDATOR_1271_ABI","verifyMessage","provider","signer","message","typedData","finalDigest","signature","undeployedCallback","utils","hashMessage","domain","types","Error","_TypedDataEncoder","hash","addrMatching","recoverAddress","eip1271Check","recoveredAddr","targetAddr","isAddress","toLowerCase","web3CompatibleProvider","ethersProvider","providers","Provider","isProvider","Web3Provider","getCode","code","contract","Contract","isValidSignature","module","exports","getMessageAsBytes","msg","isHexString","arrayify","toUtf8Bytes","useSignMessage","typeDataErr","dataV4","fetch","account","everythingToSign","relayerURL","addToast","resolve","onConfirmationCodeRequired","onLastMessageSign","getHardwareWallet","useState","isLoading","setLoading","isDeployed","setIsDeployed","hasPrivileges","setHasPrivileges","hasProviderError","setHasProviderError","confirmationType","setConfirmationType","toSign","useMemo","requestedChainId","chainId","isTypedData","indexOf","type","txn","EIP712Domain","requestedNetwork","networks","find","n","parseInt","toString","checkIsDeployedAndHasPrivileges","useCallback","a","bundle","Bundle","network","id","identity","getProvider","quickAccManager","quickAccTimelock","accountPresets","quickAccountTuple","one","two","abiCoder","AbiCoder","quickAccAccountHash","keccak256","encode","privilegeAddress","address","callObject","method","params","to","data","substring","jsonrpc","fetchPost","connection","url","then","result","catch","err","useEffect","handleSigningErr","e","includes","error","verifySignature","sig","networkId","verificationResult","approveQuickAcc","credentials","password","length","undefined","success","confCodeRequired","primaryKeyBackup","Wallet","fromEncryptedJson","JSON","parse","wallet","signMessage712","signMessage","approve","device","supportedDApps","SignMessage","connections","totalRequests","useToasts","codeRequired","passphrase","signingState","setSigningState","promiseResolve","setPromiseResolve","inputSecretRef","useRef","Promise","confCode","getWallet","signerExtra","uri","wcUri","dApp","session","peerMeta","isDAppSupported","current","focus","className","onClick","src","blockies","seed","toDataURL","alt","style","backgroundImage","icon","name","label","href","target","rel","icons","value","stringify","getMessageAsText","readOnly","onSubmit","preventDefault","required","minLength","placeholder","onChange","hidden","ref","onInput","danger","disabled","toUtf8String","_"],"mappings":"+HAAQA,EAAWC,EAAQ,IAAnBD,OAEFE,EAAqB,CAAC,kFAmBrBC,EAAa,2BAAG,kGAASC,EAAT,EAASA,SAAUC,EAAnB,EAAmBA,OAAQC,EAA3B,EAA2BA,QAASC,EAApC,EAAoCA,UAAWC,EAA/C,EAA+CA,YAAaC,EAA5D,EAA4DA,UAAWC,EAAvE,EAAuEA,oBACxFJ,EADiB,gBAEnBE,EAAcR,EAAOW,MAAMC,YAAYN,GAFpB,2BAGVC,EAHU,oBAIdA,EAAUM,QAAWN,EAAUO,OAAUP,EAAUD,QAJrC,sBAKXS,MAAM,yEALK,OAQnBP,EAAcR,EAAOW,MAAMK,kBAAkBC,KAAKV,EAAUM,OAAQN,EAAUO,MAAOP,EAAUD,SAR5E,2BASTE,EATS,uBAUbO,MAAM,uFAVO,YAcjBG,EAAaC,EAAeX,EAAaC,GAAYJ,GAdpC,2CAcoD,GAdpD,yBAiBVe,EAAahB,EAAUC,EAAQG,EAAaC,GAjBlC,uBAiBkD,eAjBlD,gDAiBuE,GAjBvE,YAoBjBC,EApBiB,+BAsBbA,EAAmBL,EAAQG,EAAaC,GAtB3B,2CAsB8C,GAtB9C,iEAwBX,IAAIM,MAAM,6BAA+B,KAAET,SAxBhC,kCA4Bd,GA5Bc,2DAAH,sDAgCda,EAAiB,SAACF,EAAMR,GAC5B,IACE,OAAOT,EAAOW,MAAMQ,eAAeF,EAAMR,GACzC,SACA,OAAO,IAKLS,EAAe,SAACG,EAAeC,GACnC,IAAsB,IAAlBD,EAAyB,OAAO,EACpC,IAAKrB,EAAOW,MAAMY,UAAUF,GAAgB,MAAM,IAAIN,MAAM,8BAAgCM,GAE5F,OAAOA,EAAcG,gBAAkBF,EAAWE,eAI9CJ,EAAY,2BAAG,WAAOK,EAAwBpB,EAAQY,EAAMR,GAA7C,gFAGjBiB,EADE1B,EAAO2B,UAAUC,SAASC,WAAWJ,GACtBA,EAEA,IAAIzB,EAAO2B,UAAUG,aAAaL,GALlC,SAOAC,EAAeK,QAAQ1B,GAPvB,YAOb2B,EAPa,SAQE,OAATA,EARO,uBASXC,EAAW,IAAIjC,EAAOkC,SAAS7B,EAAQH,EAAoBwB,GAThD,kBAUVO,EAASE,iBAAiBlB,EAAMR,IAVtB,iCAYZ,GAZY,2CAAH,4DAelB2B,EAAOC,QAAU,CACflC,kB,+NCjEF,SAASmC,EAAkBC,GAEzB,OAAKC,sBAAYD,GAGVE,mBAASF,GAFPG,sBAAYH,GAKvB,IAgVeI,EAhVQ,SAAC,GAU8B,IAShDC,EACAC,EAnBJC,EASmD,EATnDA,MACAC,EAQmD,EARnDA,QACAC,EAOmD,EAPnDA,iBACAC,EAMmD,EANnDA,WACAC,EAKmD,EALnDA,SACAC,EAImD,EAJnDA,QACAC,EAGmD,EAHnDA,2BACAC,EAEmD,EAFnDA,kBACAC,EACmD,EADnDA,kBAEA,EAAgCC,oBAAkB,GAAlD,mBAAOC,EAAP,KAAkBC,EAAlB,KACA,EAAoCF,mBAAyB,MAA7D,mBAAOG,EAAP,KAAmBC,EAAnB,KACA,EAA0CJ,mBAAyB,MAAnE,mBAAOK,EAAP,KAAsBC,EAAtB,KACA,EAAgDN,mBAAS,MAAzD,mBAAOO,EAAP,KAAyBC,EAAzB,KACA,EAAgDR,mBAAiC,MAAjF,mBAAOS,EAAP,KAAyBC,EAAzB,KAEMC,EAASC,mBAAQ,kBAAMnB,EAAiB,IAAM,KAAI,CAACA,IAIrDoB,EAAmBF,EAAOG,QACxBC,GAAuF,IAAzE,CAAC,uBAAwB,qBAAqBC,QAA9C,OAAsDL,QAAtD,IAAsDA,OAAtD,EAAsDA,EAAQM,MAClF,GAAIF,EAEF,GAAsB,kBADtBzB,EAASqB,EAAOO,MAC6B,OAAX5B,EAChC,IAAK,IAAD,UAC+B,KAML,GAN5B,aAAIA,SAAJ,iBAAI,EAAQ/B,aAAZ,aAAI,EAAe4D,aAEjB,UAAO7B,SAAP,mBAAO,EAAQ/B,aAAf,eAAO,GAAe4D,cAIxB,GAFA1D,oBAAkBC,KAAlB,UAAuB4B,SAAvB,aAAuB,EAAQhC,OAAQgC,EAAO/B,MAA9C,UAAqD+B,SAArD,aAAqD,EAAQvC,SAE7D,UAAIuC,EAAOhC,cAAX,aAAI,EAAewD,QACjBD,EAAgB,WAAGvB,EAAOhC,cAAV,cAAG,GAAewD,QAEpC,UACAzB,EAAc,6EAGhBA,EAAc,oCAIlB,ICvEkCyB,GDuE5BM,ICvE4BN,GDuEWD,ECtEtCQ,IAASC,MAAK,SAACC,GAAD,OAAOA,EAAET,UAAYU,SAASV,GAAQW,gBDwErDC,GAAkCC,sBAAW,sBAAC,sDAAAC,EAAA,yDAC7CR,GAD6C,wDAG5CS,EAAS,IAAIC,SAAO,CACxBC,QAAO,OAAEX,SAAF,IAAEA,QAAF,EAAEA,GAAkBY,GAC3BC,SAAQ,OAAEzC,QAAF,IAAEA,OAAF,EAAEA,EAASwC,GACnBlF,OAAM,OAAE0C,QAAF,IAAEA,OAAF,EAAEA,EAAS1C,SAN+B,SAS3BoF,YAAW,OAACd,SAAD,IAACA,QAAD,EAACA,GAAkBY,IATH,OAS5CnF,EAT4C,QAalD,OAAI2C,QAAJ,IAAIA,GAAJ,UAAIA,EAAS1C,cAAb,aAAI,EAAiBqF,kBACXC,EAAqBC,IAArBD,iBACFE,EAAoB,CAACF,EAAD,OAAmB5C,QAAnB,IAAmBA,GAAnB,UAAmBA,EAAS1C,cAA5B,aAAmB,EAAiByF,IAApC,OAAyC/C,QAAzC,IAAyCA,GAAzC,UAAyCA,EAAS1C,cAAlD,aAAyC,EAAiB0F,KAC9EC,EAAW,IAAIC,WACrBC,EAAsBC,oBACpBH,EAASI,OAAO,CAAC,iCAAkC,CAACP,KAEtDQ,EAAgB,UAAGtD,EAAQ1C,cAAX,aAAG,EAAgBqF,iBAEnCW,EAAgB,UAAGtD,EAAQ1C,cAAX,aAAG,EAAgBiG,QAI/BC,EAAa,CACjBC,OAAQ,WACRC,OAAQ,CACN,CACEC,GAAItB,EAAOI,SACXmB,KAAK,qCAAD,OAAuCN,EAAiB7E,cAAcoF,UAAU,KAEtF,UAEFrB,GAAI,EACJsB,QAAS,OAGXC,YAAUhE,EAAD,OAAQ1C,QAAR,IAAQA,GAAR,UAAQA,EAAU2G,kBAAlB,aAAQ,EAAsBC,IAAKT,GACzCU,MAAK,SAACC,GACyC,IAAD,EAAzCA,EAAOA,QAA4B,OAAlBA,EAAOA,QAC1BvD,GAAc,IACd,OAAIZ,QAAJ,IAAIA,GAAJ,UAAIA,EAAS1C,cAAb,aAAI,EAAiBqF,iBACnB7B,EAAiBqD,EAAOA,SAAWhB,GAKf,uEAAlBgB,EAAOA,OAEPrD,GAAiB,GAEjBA,GAAiB,IAKrBF,GAAc,MAGjBwD,OAAM,SAACC,GAGNrD,EAAoBqD,EAAI9G,YAhEsB,2CAkEjD,CAACyC,EAAS4B,GAAkB7B,IAE/BuE,qBAAU,WACRpC,OACC,CAACA,KAEJ,IAAMqC,GAAmBpC,uBACvB,SAACqC,GACmE,IAAD,EAA7DA,GAAKA,EAAEjH,QAAQkH,SAAS,oCAC1BtE,EAAS,0FAAD,iBACoFH,EAAQ1C,cAD5F,aACoF,EAAgBiG,QADpG,KAEN,CAAEmB,OAAO,IAGXvE,EAAS,kBAAD,OAAmBqE,EAAEjH,SAAWiH,GAAK,CAC3CE,OAAO,MAIb,CAAC1E,EAASG,IAGNwE,GAAkBxC,uBACtB,SAAChB,EAAQyD,EAAKC,GACZ,IAAMxH,EAAWqF,YAAYmC,GAC7B,OAAOzH,wBAAc,CACnBC,WACAC,OAAQ0C,EAAQwC,GAChBjF,QAASgE,EAAc,KAAOhC,EAAkB4B,EAAOO,KACvDlE,UAAW+D,EAAczB,EAAS,KAClCpC,UAAWkH,IAEVV,MAAK,SAACY,GACDA,EACF3E,EAAS,GAAD,OAAIgB,EAAOM,KAAX,qBAERtB,EAAS,GAAD,OAAIgB,EAAOM,KAAX,sBAAqC,CAAEiD,OAAO,OAGzDN,OAAM,SAACI,GACNrE,EAAS,GAAD,OAAIgB,EAAOM,KAAX,+BAAsC+C,EAAEjH,SAAW,CAAEmH,OAAO,SAG1E,CAAC1E,EAASG,EAAUL,EAAQyB,IAGxBwD,GAAkB5C,sBAAW,uCACjC,WAAO6C,GAAP,6BAAA5C,EAAA,yDACOlC,EADP,uBAEIC,EAAS,iEAAkE,CACzEuE,OAAO,IAHb,6BAOOM,EAAYC,SAPnB,uBAQI9E,EAAS,0CAA2C,CAAEuE,OAAO,IARjE,iCAWEhE,GAAW,GAXb,mBAaoEqD,YAC9DhE,EADuE,UAIpEG,EAJoE,uBAI3CF,EAAQwC,GAJmC,yBAKrEjB,EAAc,kBAAoB,IAEpC,CACEJ,OAAQA,EAAOO,IACfzC,MAAM,UAAA+F,EAAY/F,YAAZ,eAAkBiG,QAASF,EAAY/F,UAAOkG,IAtB5D,oBAaYzH,EAbZ,EAaYA,UAAW0H,EAbvB,EAauBA,QAAS7H,EAbhC,EAagCA,QAAS8H,EAbzC,EAayCA,iBAYhCD,EAzBT,oBA0BM1E,GAAW,GACNnD,EA3BX,uBA2B0B,IAAIS,MAAM,kDA3BpC,eA4BUT,EAAQkH,SAAS,8BACnBtE,EAAS,0CAA2C,CAAEuE,OAAO,IAE/DvE,EAAS,2BAAD,OAA4B5C,GAAW,CAC7CmH,OAAO,IAETxD,EAAoB,MACpBR,GAAW,GAnCjB,+BAuCQ2E,EAvCR,oBAwCMnE,EAAoBmE,IAEhBhF,EA1CV,kCA2CcA,EAA2BgF,EAAkBN,IA3C3D,eA8CMrE,GAAW,GA9CjB,8BAkDSV,EAAQsF,iBAlDjB,uBAmDY,IAAItH,MACR,iFApDR,yBAsDyBuH,SAAOC,kBAC1BC,KAAKC,MAAM1F,EAAQsF,kBACnBN,EAAYC,UAxDlB,eAsDUU,EAtDV,iBA0DuBpE,EACfqE,yBACED,EACA3F,EAAQwC,GACRxC,EAAQ1C,OACRwC,EAAOhC,OACPgC,EAAO/B,MACP+B,EAAOvC,QACPG,GAEFmI,sBACEF,EACA3F,EAAQwC,GACRxC,EAAQ1C,OACRiC,EAAkB4B,EAAOO,KACzBhE,GAzEV,eA0DUkH,EA1DV,iBA4EUD,GAAgBxD,EAAQyD,EAAT,OAAchD,SAAd,IAAcA,QAAd,EAAcA,GAAkBY,IA5EzD,QA8EIpC,EAAQ,CAAEgF,SAAS,EAAMjB,OAAQS,IACjCzE,EAAS,wBACuB,IAA5BF,EAAiBiF,QACjB5E,GAAqBA,IAjF7B,kDAoFIiE,GAAiB,EAAD,IApFpB,QAsFE7D,GAAW,GAtFb,0DADiC,sDAyFjC,CACEV,EACAG,EACAL,EACAG,EACAF,EACAwE,GACAhD,EACAlB,EACAC,EACAJ,EACA0B,GACAxB,EACAe,EACAwD,KAIEmB,GAAU3D,sBAAW,uCACzB,WAAO6C,EAAkBe,GAAzB,mBAAA3D,EAAA,qEACMpC,EAAQ1C,cADd,aACM,EAAgBqF,iBADtB,gCAEUoC,GAAgBC,GAF1B,+CAKEtE,GAAW,GALb,kBAQyBH,EAAkBwF,GAR3C,UAQUJ,EARV,2EAkBuC,yBAAhBxE,EAAOM,MACV,sBAAhBN,EAAOM,KACHmE,yBACED,EACA3F,EAAQwC,GACRxC,EAAQ1C,OACRwC,EAAOhC,OACPgC,EAAO/B,MACP+B,EAAOvC,SAETsI,sBAAYF,EAAQ3F,EAAQwC,GAAIxC,EAAQ1C,OAAQiC,EAAkB4B,EAAOO,MA5BjF,eAkBUkD,EAlBV,iBA8BUD,GAAgBxD,EAAQyD,EAAT,OAAchD,SAAd,IAAcA,QAAd,EAAcA,GAAkBY,IA9BzD,QAgCIpC,EAAQ,CAAEgF,SAAS,EAAMjB,OAAQS,IACjCzE,EAAS,wBAjCb,kDAmCIoE,GAAiB,EAAD,IAnCpB,QAqCE7D,GAAW,GArCb,0DADyB,wDAwCzB,CACEV,EACAG,EACA4E,GACAjF,EACAS,EACAgE,GANF,OAOE3C,SAPF,IAOEA,QAPF,EAOEA,GAAkBY,GAClBpC,EACAe,EACAwD,KAIJ,MAAO,CACLmB,WACAf,mBACA5D,SACAV,YACAI,gBACAE,mBACAlB,cACAc,aACAb,SACA8B,oBACAP,mBACAE,cACAN,qBEvWWrB,ICKAoG,EAPkB,CAC/B,uBACA,oBACA,uBACA,mC,2DCWa,SAASC,EAAT,GAAsG,IAAD,EAA9EhG,EAA8E,EAA9EA,iBAAkBG,EAA4D,EAA5DA,QAASJ,EAAmD,EAAnDA,QAASkG,EAA0C,EAA1CA,YAAahG,EAA6B,EAA7BA,WAAYiG,EAAiB,EAAjBA,cAEzFhG,EAAaiG,cAAbjG,SACR,EAAwCK,mBAFZ,CAAE6F,cAAc,EAAOC,WAAY,KAE/D,mBAAOC,EAAP,KAAqBC,EAArB,KACA,EAA4ChG,mBAAS,MAArD,mBAAOiG,EAAP,KAAuBC,EAAvB,KACMC,EAAiBC,iBAAO,MAExBvG,EAA0B,uCAAG,WAAOgF,EAAkBN,GAAzB,eAAA3C,EAAA,sEACV,IAAIyE,SAAQ,SAACzG,GAClCsG,GAAkB,kBAAMtG,QAFO,UAC3B0G,EAD2B,6BAIZ,IAAI9I,MAAM,sCAJE,uBAK3B+G,EAAgB,CACpBE,SAAUsB,EAAaD,WACvBrH,KAAM6H,IAPyB,4EAAH,wDA2BhC,EAaIlH,EAAe,CACjBG,YACAC,UACAC,mBACAC,aACAC,WACAC,UACAC,6BACAE,kBAnCwB,WAWxB,OARewG,YACb,CACEzJ,OAAQ0C,EAAQ1C,OAChB0J,YAAahH,EAAQgH,YACrB1F,QAAS,OAQbwE,EADF,EACEA,QACA3E,EAFF,EAEEA,OACAV,EAHF,EAGEA,UACAI,EAJF,EAIEA,cACAE,EALF,EAKEA,iBACAlB,EANF,EAMEA,YACAc,EAPF,EAOEA,WACAb,EARF,EAQEA,OACA8B,EATF,EASEA,iBACAP,EAVF,EAUEA,iBACAE,EAXF,EAWEA,YACAN,EAZF,EAYEA,iBAYI+C,EAAakC,EAAYpE,MAAK,qBAAGmF,MAAkB9F,EAAO+F,SAC1DC,EAAOnD,IAAuB,OAAVA,QAAU,IAAVA,GAAA,UAAAA,EAAYoD,eAAZ,eAAqBC,WAAmB,KAC5DC,EAAkBH,GAAQnB,EAAevB,SAAS0C,EAAKlD,KAM7D,GAJAK,qBAAU,WACJrD,GAAkB0F,EAAeY,QAAQC,UAC5C,CAACvG,KAECE,IAAWnB,EAAS,OAAO,6BAGhC,IAAK4B,EACH,OACE,sBAAKY,GAAG,cAAR,UACE,qBAAIiF,UAAU,QAAd,8CACoCpG,KAEpC,cAAC,IAAD,CACEoG,UAAU,SACVC,QAAS,kBAAMtH,EAAQ,CAAE7C,QAAS,sBAFpC,uBAUN,GAAIsC,EACF,OACE,sBAAK2C,GAAG,cAAR,UACE,qBAAIiF,UAAU,QAAd,sCAAgD5H,KAChD,cAAC,IAAD,CACE4H,UAAU,SACVC,QAAS,kBAAMtH,EAAQ,CAAE7C,QAAS,sBAFpC,uBAoBN,OACE,sBAAKiF,GAAG,cAAR,UACE,sBAAKA,GAAG,iBAAiBiF,UAAU,QAAnC,UACE,qBAAKA,UAAU,QAAf,kCACA,sBAAKA,UAAU,UAAf,UACE,sBAAKA,UAAU,yBAAf,UACE,qBACEA,UAAU,OACVE,IAAKC,SAAgB,CAAEC,KAAM7H,EAAQwC,KAAMsF,YAC3CC,IAAI,iBAEL/H,EAAQwC,MAEX,sBAAKiF,UAAU,yBAAf,eAEE,qBACEA,UAAU,OACVO,MAAO,CAAEC,gBAAgB,OAAD,OAASrG,EAAiBsG,KAA1B,QAE1B,qBAAKT,UAAU,UAAf,SAA0B7F,EAAiBuG,gBAIjD,sBAAKV,UAAU,QAAf,UACE,sBAAKA,UAAU,yBAAf,UACE,sBAAMA,UAAU,yBAAhB,0BACA,sBAAMA,UAAU,iCAAhB,SACE,eAAC,IAAD,CACEW,MAAK,UACH7G,EACI,qDACA,yDAJR,UAOE,cAAC,IAAD,IAAkB,IAClB,+BAAOA,EAAc,eAAiB,0BAK5C,sBAAKkG,UAAU,kBAAf,UACE,sBAAKA,UAAU,eAAf,UACGN,EACC,oBACEM,UAAU,OACVY,KAAMlB,EAAKlD,IACXqE,OAAO,SACPC,IAAI,aAJN,UAME,qBACEd,UAAU,OACVO,MAAO,CAAEC,gBAAgB,OAAD,OAASd,EAAKqB,MAAM,GAApB,MAF1B,SAIE,cAAC,IAAD,MAEDrB,EAAKgB,QAGR,UAjBJ,mCAqBA,+BACGhC,EAAgB,EAAhB,mBACeA,EAAgB,EAD/B,2BAEG,MAEJmB,GAAmB,cAAC,IAAD,OAGvB,0BACEG,UAAU,eACVhG,KAAK,OACLgH,MACE3I,EACI2F,KAAKiD,UAAU5I,EAAQ,KAAM,KACd,OAAfqB,EAAOO,IACPiH,EAAiBxH,EAAOO,KACxB,kBAENkH,UAAU,IAGZ,qBAAKnB,UAAU,UAAf,SACE,uBAAMoB,SA3FO,SAACrE,GACpBA,EAAEsE,iBACFhD,EAAQ,CACNb,SAAUsB,EAAaD,cAwFnB,UACGtG,EAAQ1C,OAAOqF,iBAAmBhC,GACjC,qCACE,cAAC,IAAD,CACEsE,UAAQ,EACR8D,UAAQ,EACRC,UAAW,EACXC,YAAY,mBACZR,MAAOlC,EAAaD,WACpB4C,SAAU,SAACT,GAAD,OACRjC,EAAgB,2BAAKD,GAAN,IAAoBD,WAAYmC,QAGnD,uBAAOhH,KAAK,SAAS0H,QAAM,OAI9BlI,GACC,qCACwB,UAArBA,GACC,+GAKoB,QAArBA,GACC,8DAEF,cAAC,IAAD,CACEmI,IAAKzC,EACLsC,YACuB,QAArBhI,EACI,yBACA,oBAENoI,QAAS,SAACZ,GAlIE,IAACjE,EApGN,KAoGMA,EAkI2BiE,GAjIhDvD,QAA6BuB,EAAejC,SAsI1B,OAAf7D,IAAwBI,GACvB,8BACE,cAAC,IAAD,OAIY,IAAfJ,GACC,gCACE,oBAAI8G,UAAU,QAAd,8CACA,qBAAIA,UAAU,QAAd,2DACiD,IAC9C7F,EAAiBuG,KAFpB,wDAQe,IAAlBtH,GACC,8BACE,oBAAI4G,UAAU,QAAd,oEAMH1G,GACC,8BACE,qBAAI0G,UAAU,QAAd,0DACgD,IAC7C1G,OAKP,sBAAK0G,UAAU,UAAf,UACE,cAAC,IAAD,CACEhG,KAAK,SACL6H,QAAM,EACNpB,KAAM,cAAC,IAAD,IACNT,UAAU,SACVC,QAAS,kBAAMtH,EAAQ,CAAE7C,QAAS,sBALpC,oBASgB,OAAfoD,GAAuBA,GAAcE,GACpC,cAAC,IAAD,CAAQY,KAAK,SAASgG,UAAU,UAAU8B,SAAU9I,EAApD,SACGA,EACC,qCACE,cAAC,IAAD,IADF,gBAKA,qCACE,cAAC,IAAD,IADF,2BAcpB,SAASkI,EAAiBnJ,GACxB,GAAIC,sBAAYD,GACd,IACE,OAAOgK,uBAAahK,GACpB,MAAOiK,GACP,OAAOjK,EAGX,OAAU,OAAHA,QAAG,IAAHA,OAAA,EAAAA,EAAKyC,UAAWzC,EAAIyC,WAAazC,EAAM,K","file":"static/js/23.b62744d0.chunk.js","sourcesContent":["const { ethers } = require('ethers')\n\nconst VALIDATOR_1271_ABI = ['function isValidSignature(bytes32 hash, bytes signature) view returns (bytes4)']\n\n/**\n * @typedef { import(\"@ethersproject/abstract-signer\").TypedDataDomain } TypedDataDomain\n * @typedef { import(\"@ethersproject/abstract-signer\").TypedDataField } TypedDataField\n * @typedef { import(\"@ethersproject/providers\").Provider } Provider\n */\n\n/**\n * @param {Provider | window.ethereum} provider Web3 Compatible provider to perform smart contract wallet validation with EIP 1271 (window.ethereum, web3.currentProvider, ethers provider... )\n * @param {string} signer The signer address to verify the signature against\n * @param {string | Uint8Array} message To verify eth_sign type of signatures. Human-readable message to verify. Message should be a human string or the hex version of the human string encoded as Uint8Array. If a hex string is passed, it will be considered as a regular string\n * @param {{domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>}} typedData To verify a 712 signature type. The {domain, type, message} 712 message object\n * @param {string} finalDigest The final digest to verify. dApp will have to pre-compute the hash as no hashing transformation will occur and this digest will be directly used for recoverAddress and isValidSignature\n * @param {string | Uint8Array} signature The signature to verify as a hex string or Uint8Array\n * @param {function(string, string, string | Uint8Array): boolean} undeployedCallback An optional 1271 callback function to gracefully handle signature validation for non-deployed smart contract wallets\n * @returns {Promise<boolean>}\n * NOTE: you only need to pass one of: typedData, finalDigest, message\n */\nconst  verifyMessage = async ({ provider, signer, message, typedData, finalDigest, signature, undeployedCallback }) => {\n  if (message) {\n    finalDigest = ethers.utils.hashMessage(message)\n  } else if (typedData) {\n    if (!typedData.domain || !typedData.types || !typedData.message) {\n      throw Error('Missing one or more properties for typedData (domain, types, message)')\n    }\n\n    finalDigest = ethers.utils._TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message)\n  } else if (!finalDigest) {\n    throw Error('Missing one of the properties: message, unPrefixedMessage, typedData or finalDigest')\n  }\n\n  // First try: elliptic curve signature (EOA)\n  if (addrMatching(recoverAddress(finalDigest, signature), signer)) return true\n\n  // 2nd try: Getting code from deployed smart contract to call 1271 isValidSignature\n  if ((await eip1271Check(provider, signer, finalDigest, signature)) === '0x1626ba7e') return true\n\n  // Last attempt, for undeployed smart contract with custom logic\n  if (undeployedCallback) {\n    try {\n      if (undeployedCallback(signer, finalDigest, signature)) return true\n    } catch (e) {\n      throw new Error('undeployedCallback error: ' + e.message)\n    }\n  }\n\n  return false\n}\n\n// Address recovery wrapper\nconst recoverAddress = (hash, signature) => {\n  try {\n    return ethers.utils.recoverAddress(hash, signature);\n  } catch {\n    return false\n  }\n}\n\n// Comparing addresses. targetAddr is already checked upstream\nconst addrMatching = (recoveredAddr, targetAddr) => {\n  if (recoveredAddr === false) return false\n  if (!ethers.utils.isAddress(recoveredAddr)) throw new Error('Invalid recovered address: ' + recoveredAddr)\n\n  return recoveredAddr.toLowerCase() === targetAddr.toLowerCase()\n}\n\n// EIP 1271 check\nconst eip1271Check = async (web3CompatibleProvider, signer, hash, signature) => {\n  let ethersProvider\n  if (ethers.providers.Provider.isProvider(web3CompatibleProvider)) {\n    ethersProvider = web3CompatibleProvider\n  } else {\n    ethersProvider = new ethers.providers.Web3Provider(web3CompatibleProvider);\n  }\n  const code = await ethersProvider.getCode(signer)\n  if (code && code !== '0x') {\n    const contract = new ethers.Contract(signer, VALIDATOR_1271_ABI, ethersProvider)\n    return contract.isValidSignature(hash, signature)\n  }\n  return false\n}\n\nmodule.exports = {\n  verifyMessage\n}\n","// @ts-nocheck TODO: Fill in all missing types before enabling the TS check again\nimport { Bundle, signMessage, signMessage712 } from 'adex-protocol-eth/js/Bundle'\nimport { Wallet } from 'ethers'\nimport {\n  _TypedDataEncoder,\n  AbiCoder,\n  arrayify,\n  isHexString,\n  keccak256,\n  toUtf8Bytes\n} from 'ethers/lib/utils'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\n\nimport { verifyMessage } from '@ambire/signature-validator'\n\nimport accountPresets from '../../constants/accountPresets'\nimport { fetchPost } from '../../services/fetch'\nimport { getNetworkByChainId } from '../../services/getNetwork'\nimport { getProvider } from '../../services/provider'\nimport { UseSignMessageProps, UseSignMessageReturnType } from './types'\n\nfunction getMessageAsBytes(msg: string) {\n  // Transforming human message / hex string to bytes\n  if (!isHexString(msg)) {\n    return toUtf8Bytes(msg)\n  }\n  return arrayify(msg)\n}\n\nconst useSignMessage = ({\n  fetch,\n  account,\n  everythingToSign,\n  relayerURL,\n  addToast,\n  resolve,\n  onConfirmationCodeRequired,\n  onLastMessageSign,\n  getHardwareWallet\n}: UseSignMessageProps): UseSignMessageReturnType => {\n  const [isLoading, setLoading] = useState<boolean>(false)\n  const [isDeployed, setIsDeployed] = useState<null | boolean>(null)\n  const [hasPrivileges, setHasPrivileges] = useState<null | boolean>(null)\n  const [hasProviderError, setHasProviderError] = useState(null)\n  const [confirmationType, setConfirmationType] = useState<'email' | 'otp' | null>(null)\n\n  const toSign = useMemo(() => everythingToSign[0] || {}, [everythingToSign])\n\n  let typeDataErr\n  let dataV4: any\n  let requestedChainId = toSign.chainId\n  const isTypedData = ['eth_signTypedData_v4', 'eth_signTypedData'].indexOf(toSign?.type) !== -1\n  if (isTypedData) {\n    dataV4 = toSign.txn\n    if (typeof dataV4 === 'object' && dataV4 !== null) {\n      try {\n        if (dataV4?.types?.EIP712Domain) {\n          // Avoids failure in case some dapps explicitly add this (redundant) prop\n          delete dataV4?.types?.EIP712Domain\n        }\n        _TypedDataEncoder.hash(dataV4?.domain, dataV4.types, dataV4?.message)\n        // enforce chainId\n        if (dataV4.domain?.chainId) {\n          requestedChainId = dataV4.domain?.chainId\n        }\n      } catch {\n        typeDataErr = '.txn has Invalid TypedData object. Should be {domain, types, message}'\n      }\n    } else {\n      typeDataErr = '.txn should be a TypedData object'\n    }\n  }\n\n  const requestedNetwork = getNetworkByChainId(requestedChainId)\n\n  const checkIsDeployedAndHasPrivileges = useCallback(async () => {\n    if (!requestedNetwork) return\n\n    const bundle = new Bundle({\n      network: requestedNetwork?.id,\n      identity: account?.id,\n      signer: account?.signer\n    })\n\n    const provider = await getProvider(requestedNetwork?.id)\n\n    let privilegeAddress: any\n    let quickAccAccountHash: any\n    if (account?.signer?.quickAccManager) {\n      const { quickAccTimelock } = accountPresets\n      const quickAccountTuple = [quickAccTimelock, account?.signer?.one, account?.signer?.two]\n      const abiCoder = new AbiCoder()\n      quickAccAccountHash = keccak256(\n        abiCoder.encode(['tuple(uint, address, address)'], [quickAccountTuple])\n      )\n      privilegeAddress = account.signer?.quickAccManager\n    } else {\n      privilegeAddress = account.signer?.address\n    }\n\n    // to differenciate reverts and network issues\n    const callObject = {\n      method: 'eth_call',\n      params: [\n        {\n          to: bundle.identity,\n          data: `0xc066a5b1000000000000000000000000${privilegeAddress.toLowerCase().substring(2)}`\n        },\n        'latest'\n      ],\n      id: 1,\n      jsonrpc: '2.0'\n    }\n\n    fetchPost(fetch, provider?.connection?.url, callObject)\n      .then((result: any) => {\n        if (result.result && result.result !== '0x') {\n          setIsDeployed(true)\n          if (account?.signer?.quickAccManager) {\n            setHasPrivileges(result.result === quickAccAccountHash)\n          } else {\n            // TODO: To ask : in what cases it's more than 1?\n            // eslint-disable-next-line no-lonely-if\n            if (\n              result.result === '0x0000000000000000000000000000000000000000000000000000000000000001'\n            ) {\n              setHasPrivileges(true)\n            } else {\n              setHasPrivileges(false)\n            }\n          }\n        } else {\n          // result.error or anything else that does not have a .result prop, we assume it is not deployed\n          setIsDeployed(false)\n        }\n      })\n      .catch((err) => {\n        // as raw XHR calls, reverts are not caught, but only have .error prop\n        // this should be a netowrk error\n        setHasProviderError(err.message)\n      })\n  }, [account, requestedNetwork, fetch])\n\n  useEffect(() => {\n    checkIsDeployedAndHasPrivileges()\n  }, [checkIsDeployedAndHasPrivileges])\n\n  const handleSigningErr = useCallback(\n    (e: any) => {\n      if (e && e.message.includes('must provide an Ethereum address')) {\n        addToast(\n          `Signing error: not connected with the correct address. Make sure you're connected with ${account.signer?.address}.`,\n          { error: true }\n        )\n      } else {\n        addToast(`Signing error: ${e.message || e}`, {\n          error: true\n        })\n      }\n    },\n    [account, addToast]\n  )\n\n  const verifySignature = useCallback(\n    (toSign, sig, networkId) => {\n      const provider = getProvider(networkId)\n      return verifyMessage({\n        provider,\n        signer: account.id,\n        message: isTypedData ? null : getMessageAsBytes(toSign.txn),\n        typedData: isTypedData ? dataV4 : null,\n        signature: sig\n      })\n        .then((verificationResult: any) => {\n          if (verificationResult) {\n            addToast(`${toSign.type} SIGNATURE VALID`)\n          } else {\n            addToast(`${toSign.type} SIGNATURE INVALID`, { error: true })\n          }\n        })\n        .catch((e: any) => {\n          addToast(`${toSign.type} SIGNATURE INVALID: ${e.message}`, { error: true })\n        })\n    },\n    [account, addToast, dataV4, isTypedData]\n  )\n\n  const approveQuickAcc = useCallback(\n    async (credentials: any) => {\n      if (!relayerURL) {\n        addToast('Email/pass accounts not supported without a relayer connection', {\n          error: true\n        })\n        return\n      }\n      if (!credentials.password) {\n        addToast('Password required to unlock the account', { error: true })\n        return\n      }\n      setLoading(true)\n      try {\n        const { signature, success, message, confCodeRequired } = await fetchPost(\n          fetch,\n          // network doesn't matter when signing\n          // if it does tho, we can use ${network.id}\n          `${relayerURL}/second-key/${account.id}/ethereum/sign${\n            isTypedData ? '?typedData=true' : ''\n          }`,\n          {\n            toSign: toSign.txn,\n            code: credentials.code?.length ? credentials.code : undefined\n          }\n        )\n        if (!success) {\n          setLoading(false)\n          if (!message) throw new Error('Secondary key: no success but no error message')\n          if (message.includes('invalid confirmation code')) {\n            addToast('Unable to sign: wrong confirmation code', { error: true })\n          }\n          addToast(`Second signature error: ${message}`, {\n            error: true\n          })\n          setConfirmationType(null)\n          setLoading(false)\n\n          return\n        }\n        if (confCodeRequired) {\n          setConfirmationType(confCodeRequired)\n\n          if (onConfirmationCodeRequired) {\n            await onConfirmationCodeRequired(confCodeRequired, approveQuickAcc)\n          }\n\n          setLoading(false)\n          return\n        }\n\n        if (!account.primaryKeyBackup)\n          throw new Error(\n            'No key backup found: you need to import the account from JSON or login again.'\n          )\n        const wallet = await Wallet.fromEncryptedJson(\n          JSON.parse(account.primaryKeyBackup),\n          credentials.password\n        )\n        const sig = await (isTypedData\n          ? signMessage712(\n              wallet,\n              account.id,\n              account.signer,\n              dataV4.domain,\n              dataV4.types,\n              dataV4.message,\n              signature\n            )\n          : signMessage(\n              wallet,\n              account.id,\n              account.signer,\n              getMessageAsBytes(toSign.txn),\n              signature\n            ))\n\n        await verifySignature(toSign, sig, requestedNetwork?.id)\n\n        resolve({ success: true, result: sig })\n        addToast('Successfully signed!')\n        if (everythingToSign.length === 1) {\n          !!onLastMessageSign && onLastMessageSign()\n        }\n      } catch (e) {\n        handleSigningErr(e)\n      }\n      setLoading(false)\n    },\n    [\n      account,\n      addToast,\n      dataV4,\n      everythingToSign,\n      fetch,\n      handleSigningErr,\n      isTypedData,\n      onConfirmationCodeRequired,\n      onLastMessageSign,\n      relayerURL,\n      requestedNetwork,\n      resolve,\n      toSign,\n      verifySignature\n    ]\n  )\n  // Passing hardware device is required only for the mobile app\n  const approve = useCallback(\n    async (credentials: any, device?: any) => {\n      if (account.signer?.quickAccManager) {\n        await approveQuickAcc(credentials)\n        return\n      }\n      setLoading(true)\n\n      try {\n        const wallet = await getHardwareWallet(device)\n\n        if (!wallet) {\n          return\n        }\n\n        // It would be great if we could pass the full data cause then web3 wallets/hw wallets can display the full text\n        // Unfortunately that isn't possible, because isValidSignature only takes a bytes32 hash; so to sign this with\n        // a personal message, we need to be signing the hash itself as binary data such that we match 'Ethereum signed message:\\n32<hash binary data>' on the contract\n\n        const sig = await (toSign.type === 'eth_signTypedData_v4' ||\n        toSign.type === 'eth_signTypedData'\n          ? signMessage712(\n              wallet,\n              account.id,\n              account.signer,\n              dataV4.domain,\n              dataV4.types,\n              dataV4.message\n            )\n          : signMessage(wallet, account.id, account.signer, getMessageAsBytes(toSign.txn)))\n\n        await verifySignature(toSign, sig, requestedNetwork?.id)\n\n        resolve({ success: true, result: sig })\n        addToast('Successfully signed!')\n      } catch (e) {\n        handleSigningErr(e)\n      }\n      setLoading(false)\n    },\n    [\n      account,\n      addToast,\n      approveQuickAcc,\n      dataV4,\n      getHardwareWallet,\n      handleSigningErr,\n      requestedNetwork?.id,\n      resolve,\n      toSign,\n      verifySignature\n    ]\n  )\n\n  return {\n    approve,\n    approveQuickAcc,\n    toSign,\n    isLoading,\n    hasPrivileges,\n    hasProviderError,\n    typeDataErr,\n    isDeployed,\n    dataV4,\n    requestedNetwork,\n    requestedChainId,\n    isTypedData,\n    confirmationType\n  }\n}\n\nexport default useSignMessage\n","import networks from '../../constants/networks'\n\nexport const getNetworkByChainId = (chainId: string | number) => {\n  return networks.find((n) => n.chainId === parseInt(chainId.toString()))\n}\n\nexport const getNetworkById = (id: string | number) => {\n  return networks.find((n) => n.id === id)\n}\n","import useSignMessage from './useSignMessage'\n\nexport default useSignMessage\n","const supportedDApps: string[] = [\n  'https://snapshot.org',\n  'https://guild.xyz',\n  'https://sudoswap.xyz',\n  'https://evm-sigtools.ambire.com'\n]\n\nexport default supportedDApps\n","import useSignMessage from \"ambire-common/src/hooks/useSignMessage\"\nimport supportedDApps from \"ambire-common/src/constants/supportedDApps\"\n\nimport \"./SignMessage.scss\"\n\nimport { MdBrokenImage, MdCheck, MdClose, MdInfoOutline } from \"react-icons/md\"\nimport { toUtf8String, isHexString } from \"ethers/lib/utils\"\nimport * as blockies from \"blockies-ts\"\nimport { getWallet } from \"lib/getWallet\"\nimport { useToasts } from \"hooks/toasts\"\nimport { useState, useEffect, useRef } from \"react\"\nimport { Button, Loading, TextInput, ToolTip, DAppIncompatibilityWarningMsg } from \"components/common\"\n\nconst CONF_CODE_LENGTH = 6\n\nexport default function SignMessage({ everythingToSign, resolve, account, connections, relayerURL, totalRequests }) {\n  const defaultState = () => ({ codeRequired: false, passphrase: \"\" })\n  const { addToast } = useToasts()\n  const [signingState, setSigningState] = useState(defaultState())\n  const [promiseResolve, setPromiseResolve] = useState(null)\n  const inputSecretRef = useRef(null)\n\n  const onConfirmationCodeRequired = async (confCodeRequired, approveQuickAcc) => {\n    const confCode = await new Promise((resolve) => {\n      setPromiseResolve(() => resolve)\n    })\n    if (!confCode) throw new Error(\"You must enter a confirmation code\")\n    await approveQuickAcc({\n      password: signingState.passphrase,\n      code: confCode\n    })\n\n    return\n  }\n\n  const getHardwareWallet = () => {\n    // if quick account, wallet = await fromEncryptedBackup\n    // and just pass the signature as secondSig to signMsgHash\n    const wallet = getWallet(\n      {\n        signer: account.signer,\n        signerExtra: account.signerExtra,\n        chainId: 1 // does not matter\n      }\n    )\n\n    return wallet\n  }\n\n  const {\n    approve,\n    toSign,\n    isLoading,\n    hasPrivileges,\n    hasProviderError,\n    typeDataErr,\n    isDeployed,\n    dataV4,\n    requestedNetwork,\n    requestedChainId,\n    isTypedData,\n    confirmationType\n  } = useSignMessage({\n    fetch,\n    account,\n    everythingToSign,\n    relayerURL,\n    addToast,\n    resolve,\n    onConfirmationCodeRequired,\n    getHardwareWallet\n  })\n\n  const connection = connections.find(({ uri }) => uri === toSign.wcUri)\n  const dApp = connection ? connection?.session?.peerMeta || null : null\n  const isDAppSupported = dApp && supportedDApps.includes(dApp.url)\n\n  useEffect(() => {\n    if (confirmationType) inputSecretRef.current.focus()\n  }, [confirmationType])\n\n  if (!toSign || !account) return <></>\n\n  // should not happen unless chainId is dropped for some reason in addRequests\n  if (!requestedNetwork) {\n    return (\n      <div id='signMessage'>\n        <h3 className='error'>\n          Inexistant network for chainId : {requestedChainId}\n        </h3>\n        <Button\n          className='reject'\n          onClick={() => resolve({ message: \"signature denied\" })}\n        >\n          Reject\n        </Button>\n      </div>\n    )\n  }\n\n  if (typeDataErr)\n    return (\n      <div id='signMessage'>\n        <h3 className='error'>Invalid signing request: {typeDataErr}</h3>\n        <Button\n          className='reject'\n          onClick={() => resolve({ message: \"signature denied\" })}\n        >\n          Reject\n        </Button>\n      </div>\n    )\n\n  const handleInputConfCode = (e) => {\n    if (e.length === CONF_CODE_LENGTH) promiseResolve(e)\n  }\n\n  const handleSubmit = (e) => {\n    e.preventDefault()\n    approve({\n      password: signingState.passphrase\n    })\n  }\n\n  return (\n    <div id='signMessage'>\n      <div id='signingAccount' className='panel'>\n        <div className='title'>Signing with account</div>\n        <div className='content'>\n          <div className='signingAccount-account'>\n            <img\n              className='icon'\n              src={blockies.create({ seed: account.id }).toDataURL()}\n              alt='Account Icon'\n            />\n            {account.id}\n          </div>\n          <div className='signingAccount-network'>\n            on\n            <div\n              className='icon'\n              style={{ backgroundImage: `url(${requestedNetwork.icon})` }}\n            />\n            <div className='address'>{requestedNetwork.name}</div>\n          </div>\n        </div>\n      </div>\n      <div className='panel'>\n        <div className='title signMessageTitle'>\n          <span className='signMessageTitle-title'>Sign message</span>\n          <span className='signMessageTitle-signatureType'>\n            <ToolTip\n              label={`${\n                isTypedData\n                  ? \"An EIP-712 typed data signature has been requested\"\n                  : \"An ethSign ethereum signature type has been requested\"\n              }`}\n            >\n              <MdInfoOutline />{\" \"}\n              <span>{isTypedData ? \"EIP-712 type\" : \"standard type\"}</span>\n            </ToolTip>\n          </span>\n        </div>\n\n        <div className='request-message'>\n          <div className='dapp-message'>\n            {dApp ? (\n              <a\n                className='dapp'\n                href={dApp.url}\n                target='_blank'\n                rel='noreferrer'\n              >\n                <div\n                  className='icon'\n                  style={{ backgroundImage: `url(${dApp.icons[0]})` }}\n                >\n                  <MdBrokenImage />\n                </div>\n                {dApp.name}\n              </a>\n            ) : (\n              \"A dApp \"\n            )}\n            is requesting your signature.\n          </div>\n          <span>\n            {totalRequests > 1\n              ? `You have ${totalRequests - 1} more pending requests.`\n              : \"\"}\n          </span>\n          {!isDAppSupported && <DAppIncompatibilityWarningMsg />}\n        </div>\n\n        <textarea\n          className='sign-message'\n          type='text'\n          value={\n            dataV4\n              ? JSON.stringify(dataV4, \"\\n\", \" \")\n              : toSign.txn !== \"0x\"\n              ? getMessageAsText(toSign.txn)\n              : \"(Empty message)\"\n          }\n          readOnly={true}\n        />\n\n        <div className='actions'>\n          <form onSubmit={handleSubmit}>\n            {account.signer.quickAccManager && isDeployed && (\n              <>\n                <TextInput\n                  password\n                  required\n                  minLength={3}\n                  placeholder='Account password'\n                  value={signingState.passphrase}\n                  onChange={(value) =>\n                    setSigningState({ ...signingState, passphrase: value })\n                  }\n                ></TextInput>\n                <input type='submit' hidden />\n              </>\n            )}\n\n            {confirmationType && (\n              <>\n                {confirmationType === \"email\" && (\n                  <span>\n                    A confirmation code has been sent to your email, it is valid\n                    for 3 minutes.\n                  </span>\n                )}\n                {confirmationType === \"otp\" && (\n                  <span>Please enter your OTP code</span>\n                )}\n                <TextInput\n                  ref={inputSecretRef}\n                  placeholder={\n                    confirmationType === \"otp\"\n                      ? \"Authenticator OTP code\"\n                      : \"Confirmation code\"\n                  }\n                  onInput={(value) => handleInputConfCode(value)}\n                />\n              </>\n            )}\n\n            {isDeployed === null && !hasProviderError && (\n              <div>\n                <Loading />\n              </div>\n            )}\n\n            {isDeployed === false && (\n              <div>\n                <h3 className='error'>You can't sign this message yet.</h3>\n                <h3 className='error'>\n                  You need to complete your first transaction on{\" \"}\n                  {requestedNetwork.name} network in order to be able to sign\n                  messages.\n                </h3>\n              </div>\n            )}\n\n            {hasPrivileges === false && (\n              <div>\n                <h3 className='error'>\n                  You do not have the privileges to sign this message.\n                </h3>\n              </div>\n            )}\n\n            {hasProviderError && (\n              <div>\n                <h3 className='error'>\n                  There was an issue with the network provider:{\" \"}\n                  {hasProviderError}\n                </h3>\n              </div>\n            )}\n\n            <div className='buttons'>\n              <Button\n                type='button'\n                danger\n                icon={<MdClose />}\n                className='reject'\n                onClick={() => resolve({ message: \"signature denied\" })}\n              >\n                Reject\n              </Button>\n              {isDeployed !== null && isDeployed && hasPrivileges && (\n                <Button type='submit' className='approve' disabled={isLoading}>\n                  {isLoading ? (\n                    <>\n                      <Loading />\n                      Signing...\n                    </>\n                  ) : (\n                    <>\n                      <MdCheck /> Sign\n                    </>\n                  )}\n                </Button>\n              )}\n            </div>\n          </form>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nfunction getMessageAsText(msg) {\n  if (isHexString(msg)) {\n    try {\n      return toUtf8String(msg)\n    } catch (_) {\n      return msg\n    }\n  }\n  return msg?.toString ? msg.toString() : msg + \"\" //what if dapp sends it as object? force string to avoid app crashing\n}\n"],"sourceRoot":""}