{"version":3,"sources":["../node_modules/@ambire/signature-validator/index.js","../node_modules/ambire-common/src/hooks/useSignMessage/useSignMessage.ts","../node_modules/ambire-common/src/services/getNetwork/getNetwork.ts","../node_modules/ambire-common/src/hooks/useSignMessage/index.ts","../node_modules/ambire-common/src/constants/supportedDApps.ts","components/SignMessage/SignMessage.js","lib/lattice.js","lib/ledgerWebHID.js","lib/getWallet.js"],"names":["ethers","require","VALIDATOR_1271_ABI","verifyMessage","provider","signer","message","typedData","finalDigest","signature","undeployedCallback","utils","hashMessage","domain","types","Error","_TypedDataEncoder","hash","addrMatching","recoverAddress","eip1271Check","recoveredAddr","targetAddr","isAddress","toLowerCase","web3CompatibleProvider","ethersProvider","providers","Provider","isProvider","Web3Provider","getCode","code","contract","Contract","isValidSignature","module","exports","getMessageAsBytes","msg","isHexString","arrayify","toUtf8Bytes","useSignMessage","typeDataErr","dataV4","fetch","account","everythingToSign","relayerURL","addToast","resolve","onConfirmationCodeRequired","onLastMessageSign","getHardwareWallet","useStorage","useState","isLoading","setLoading","isDeployed","setIsDeployed","hasPrivileges","setHasPrivileges","hasProviderError","setHasProviderError","confirmationType","setConfirmationType","toSign","useMemo","key","defaultValue","signedMessages","setSignedMessages","dApp","dapp","requestedChainId","chainId","isTypedData","indexOf","type","txn","startsWith","JSON","parse","error","EIP712Domain","requestedNetwork","networks","find","n","parseInt","toString","checkIsDeployedAndHasPrivileges","useCallback","a","bundle","Bundle","network","id","identity","getProvider","quickAccManager","quickAccTimelock","accountPresets","quickAccountTuple","one","two","abiCoder","AbiCoder","quickAccAccountHash","keccak256","encode","privilegeAddress","address","callObject","method","params","to","data","substring","jsonrpc","fetchPost","connection","url","then","result","catch","err","useEffect","handleSigningErr","e","includes","verifySignature","sig","networkId","verificationResult","approveQuickAcc","credentials","password","length","undefined","success","confCodeRequired","primaryKeyBackup","Wallet","fromEncryptedJson","wallet","signMessage712","signMessage","accountId","date","Date","getTime","typed","approve","device","supportedDApps","SignMessage","totalRequests","useToasts","codeRequired","passphrase","signingState","setSigningState","promiseResolve","setPromiseResolve","inputSecretRef","useRef","Promise","confCode","getWallet","signerExtra","useLocalStorage","isDAppSupported","current","focus","className","onClick","src","blockies","seed","toDataURL","alt","style","backgroundImage","icon","name","label","href","target","rel","icons","value","stringify","getMessageAsText","readOnly","onSubmit","preventDefault","required","minLength","placeholder","onChange","hidden","ref","onInput","danger","disabled","toUtf8String","_","crypto","HARDENED_OFFSET","getAddressesReqOpts","startPath","latticeInit","commKey","clientConfig","privKey","Client","latticeConnect","client","deviceId","reject","connect","isPaired","errConnect","console","latticePair","secret","pair","hasActiveWallet","errPair","latticeGetAddresses","getAddresses","res","errGetAddresses","latticeSignMessage","dataMsg","protocol","payload","hexlify","signerPath","signOptsMsg","currency","sign","signedTx","signedMsg","r","s","v","errSignMessage","latticeSignMessage712","reqData","latticeSignTransaction","gas","gasPrice","nonce","unsignedTxObj","gasLimit","from","txData","useEIP155","signOpts","serializedSigned","serialize","errSignTxn","ethUtil","HDNode","connectedDevices","PARENT_HD_PATH","getTransport","TransportWebHID","list","opened","open","request","ledgerGetAddresses","transport","getAccounts","accounts","close","map","parentKeyDerivationPath","getAddressInternal","o","statusCode","ledgerResponse","hdKey","publicKey","Buffer","chainCode","mainAddress","addressOfHDKey","initialDerivedKeyInfo","derivationPath","baseDerivationPath","calculateDerivedHDKeyInfos","appEth","AppEth","ledgerTimeout","timeoutHandle","setTimeout","race","getAddress","clearTimeout","ledgerSignTransaction","fromAddr","serializedUnsigned","accountsData","signTransaction","substr","rsvResponse","intV","Math","floor","ledgerSignMessage","signerAddress","signPersonalMessage","rsvReply","ledgerSignMessage712","domainSeparator","hashStructMessage","signEIP712HashedMessage","count","derivedKeys","i","fullDerivationPath","path","derive","derivedKey","push","derivedPublicKey","ethereumAddressUnprefixed","publicToAddress","addHexPrefix","wallets","opts","getWalletNew","TrezorConnect","manifest","email","appUrl","providerTrezor","TrezorSubprovider","trezorConnectClientApi","_initialDerivedKeyInfo","fromExtendedKey","info","xpub","getInitialDerivedKeyInfo","signPersonalMessageAsync","signTransactionAsync","sendTransaction","transaction","broadcastProvider","getTransactionCount","isConnected","matchAddress","getAccountsAsync","addresses","_signTypedData","hashDomain","hashStruct","getPrimaryType","getPayload","_initialDerivedKeyInfoAsync","derivedKeyInfo","_findDerivedKeyInfoForAddress","_trezorConnectClientApi","ethereumSignTypedData","metamask_v4_compat","domain_separator_hash","message_hash","response","transportProtocol","LedgerSubprovider","ledgerEthereumClientFactoryAsync","ledgerEthereumBrowserClientFactoryAsync","wrapLatticeError","window","ethereum","signerObject","getSigner","matchChain","listAccounts","match","getNetwork","fn","arg","apply","this"],"mappings":"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","file":"static/js/20.aa322630.chunk.js","sourcesContent":["const { ethers } = require('ethers')\n\nconst VALIDATOR_1271_ABI = ['function isValidSignature(bytes32 hash, bytes signature) view returns (bytes4)']\n\n/**\n * @typedef { import(\"@ethersproject/abstract-signer\").TypedDataDomain } TypedDataDomain\n * @typedef { import(\"@ethersproject/abstract-signer\").TypedDataField } TypedDataField\n * @typedef { import(\"@ethersproject/providers\").Provider } Provider\n */\n\n/**\n * @param {Provider | window.ethereum} provider Web3 Compatible provider to perform smart contract wallet validation with EIP 1271 (window.ethereum, web3.currentProvider, ethers provider... )\n * @param {string} signer The signer address to verify the signature against\n * @param {string | Uint8Array} message To verify eth_sign type of signatures. Human-readable message to verify. Message should be a human string or the hex version of the human string encoded as Uint8Array. If a hex string is passed, it will be considered as a regular string\n * @param {{domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>}} typedData To verify a 712 signature type. The {domain, type, message} 712 message object\n * @param {string} finalDigest The final digest to verify. dApp will have to pre-compute the hash as no hashing transformation will occur and this digest will be directly used for recoverAddress and isValidSignature\n * @param {string | Uint8Array} signature The signature to verify as a hex string or Uint8Array\n * @param {function(string, string, string | Uint8Array): boolean} undeployedCallback An optional 1271 callback function to gracefully handle signature validation for non-deployed smart contract wallets\n * @returns {Promise<boolean>}\n * NOTE: you only need to pass one of: typedData, finalDigest, message\n */\nconst  verifyMessage = async ({ provider, signer, message, typedData, finalDigest, signature, undeployedCallback }) => {\n  if (message) {\n    finalDigest = ethers.utils.hashMessage(message)\n  } else if (typedData) {\n    if (!typedData.domain || !typedData.types || !typedData.message) {\n      throw Error('Missing one or more properties for typedData (domain, types, message)')\n    }\n\n    finalDigest = ethers.utils._TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message)\n  } else if (!finalDigest) {\n    throw Error('Missing one of the properties: message, unPrefixedMessage, typedData or finalDigest')\n  }\n\n  // First try: elliptic curve signature (EOA)\n  if (addrMatching(recoverAddress(finalDigest, signature), signer)) return true\n\n  // 2nd try: Getting code from deployed smart contract to call 1271 isValidSignature\n  if ((await eip1271Check(provider, signer, finalDigest, signature)) === '0x1626ba7e') return true\n\n  // Last attempt, for undeployed smart contract with custom logic\n  if (undeployedCallback) {\n    try {\n      if (undeployedCallback(signer, finalDigest, signature)) return true\n    } catch (e) {\n      throw new Error('undeployedCallback error: ' + e.message)\n    }\n  }\n\n  return false\n}\n\n// Address recovery wrapper\nconst recoverAddress = (hash, signature) => {\n  try {\n    return ethers.utils.recoverAddress(hash, signature);\n  } catch {\n    return false\n  }\n}\n\n// Comparing addresses. targetAddr is already checked upstream\nconst addrMatching = (recoveredAddr, targetAddr) => {\n  if (recoveredAddr === false) return false\n  if (!ethers.utils.isAddress(recoveredAddr)) throw new Error('Invalid recovered address: ' + recoveredAddr)\n\n  return recoveredAddr.toLowerCase() === targetAddr.toLowerCase()\n}\n\n// EIP 1271 check\nconst eip1271Check = async (web3CompatibleProvider, signer, hash, signature) => {\n  let ethersProvider\n  if (ethers.providers.Provider.isProvider(web3CompatibleProvider)) {\n    ethersProvider = web3CompatibleProvider\n  } else {\n    ethersProvider = new ethers.providers.Web3Provider(web3CompatibleProvider);\n  }\n  const code = await ethersProvider.getCode(signer)\n  if (code && code !== '0x') {\n    const contract = new ethers.Contract(signer, VALIDATOR_1271_ABI, ethersProvider)\n    return contract.isValidSignature(hash, signature)\n  }\n  return false\n}\n\nmodule.exports = {\n  verifyMessage\n}\n","// @ts-nocheck TODO: Fill in all missing types before enabling the TS check again\nimport { Bundle, signMessage, signMessage712 } from 'adex-protocol-eth/js/Bundle'\nimport { Wallet } from 'ethers'\nimport {\n  _TypedDataEncoder,\n  AbiCoder,\n  arrayify,\n  isHexString,\n  keccak256,\n  toUtf8Bytes\n} from 'ethers/lib/utils'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\n\nimport { verifyMessage } from '@ambire/signature-validator'\n\nimport accountPresets from '../../constants/accountPresets'\nimport { fetchPost } from '../../services/fetch'\nimport { getNetworkByChainId } from '../../services/getNetwork'\nimport { getProvider } from '../../services/provider'\nimport { UseSignMessageProps, UseSignMessageReturnType } from './types'\n\nfunction getMessageAsBytes(msg: string) {\n  // Transforming human message / hex string to bytes\n  if (!isHexString(msg)) {\n    return toUtf8Bytes(msg)\n  }\n  return arrayify(msg)\n}\n\nconst useSignMessage = ({\n  fetch,\n  account,\n  everythingToSign,\n  relayerURL,\n  addToast,\n  resolve,\n  onConfirmationCodeRequired,\n  onLastMessageSign,\n  getHardwareWallet,\n  useStorage\n}: UseSignMessageProps): UseSignMessageReturnType => {\n  const [isLoading, setLoading] = useState<boolean>(false)\n  const [isDeployed, setIsDeployed] = useState<null | boolean>(null)\n  const [hasPrivileges, setHasPrivileges] = useState<null | boolean>(null)\n  const [hasProviderError, setHasProviderError] = useState(null)\n  const [confirmationType, setConfirmationType] = useState<'email' | 'otp' | null>(null)\n\n  const toSign = useMemo(() => everythingToSign[0] || {}, [everythingToSign])\n\n  const [signedMessages, setSignedMessages] = useStorage({\n    key: 'signedMessages',\n    defaultValue: []\n  })\n\n  const dApp = toSign.dapp\n\n  let typeDataErr\n  let dataV4: any\n  let requestedChainId = toSign.chainId\n  const isTypedData = ['eth_signTypedData_v4', 'eth_signTypedData'].indexOf(toSign?.type) !== -1\n  if (isTypedData) {\n    dataV4 = toSign.txn\n    try {\n      if (dataV4.startsWith('{')) {\n        dataV4 = JSON.parse(toSign.txn)\n      }\n    } catch (error) {\n      dataV4 = toSign.txn\n    }\n    if (typeof dataV4 === 'object' && dataV4 !== null) {\n      try {\n        if (dataV4?.types?.EIP712Domain) {\n          // Avoids failure in case some dapps explicitly add this (redundant) prop\n          delete dataV4?.types?.EIP712Domain\n        }\n        _TypedDataEncoder.hash(dataV4?.domain, dataV4.types, dataV4?.message)\n        // enforce chainId\n        if (dataV4.domain?.chainId) {\n          requestedChainId = dataV4.domain?.chainId\n        }\n      } catch {\n        typeDataErr = '.txn has Invalid TypedData object. Should be {domain, types, message}'\n      }\n    } else {\n      typeDataErr = '.txn should be a TypedData object'\n    }\n  }\n\n  const requestedNetwork = getNetworkByChainId(requestedChainId)\n\n  const checkIsDeployedAndHasPrivileges = useCallback(async () => {\n    if (!requestedNetwork) return\n\n    const bundle = new Bundle({\n      network: requestedNetwork?.id,\n      identity: account?.id,\n      signer: account?.signer\n    })\n\n    const provider = await getProvider(requestedNetwork?.id)\n\n    let privilegeAddress: any\n    let quickAccAccountHash: any\n    if (account?.signer?.quickAccManager) {\n      const { quickAccTimelock } = accountPresets\n      const quickAccountTuple = [quickAccTimelock, account?.signer?.one, account?.signer?.two]\n      const abiCoder = new AbiCoder()\n      quickAccAccountHash = keccak256(\n        abiCoder.encode(['tuple(uint, address, address)'], [quickAccountTuple])\n      )\n      privilegeAddress = account.signer?.quickAccManager\n    } else {\n      privilegeAddress = account.signer?.address\n    }\n\n    // to differenciate reverts and network issues\n    const callObject = {\n      method: 'eth_call',\n      params: [\n        {\n          to: bundle.identity,\n          data: `0xc066a5b1000000000000000000000000${privilegeAddress.toLowerCase().substring(2)}`\n        },\n        'latest'\n      ],\n      id: 1,\n      jsonrpc: '2.0'\n    }\n\n    fetchPost(fetch, provider?.connection?.url, callObject)\n      .then((result: any) => {\n        if (result.result && result.result !== '0x') {\n          setIsDeployed(true)\n          if (account?.signer?.quickAccManager) {\n            setHasPrivileges(result.result === quickAccAccountHash)\n          } else {\n            // TODO: To ask : in what cases it's more than 1?\n            // eslint-disable-next-line no-lonely-if\n            if (\n              result.result === '0x0000000000000000000000000000000000000000000000000000000000000001'\n            ) {\n              setHasPrivileges(true)\n            } else {\n              setHasPrivileges(false)\n            }\n          }\n        } else {\n          // result.error or anything else that does not have a .result prop, we assume it is not deployed\n          setIsDeployed(false)\n        }\n      })\n      .catch((err) => {\n        // as raw XHR calls, reverts are not caught, but only have .error prop\n        // this should be a netowrk error\n        setHasProviderError(err.message)\n      })\n  }, [account, requestedNetwork, fetch])\n\n  useEffect(() => {\n    checkIsDeployedAndHasPrivileges()\n  }, [checkIsDeployedAndHasPrivileges])\n\n  const handleSigningErr = useCallback(\n    (e: any) => {\n      if (e && e.message.includes('must provide an Ethereum address')) {\n        addToast(\n          `Signing error: not connected with the correct address. Make sure you're connected with ${account.signer?.address}.`,\n          { error: true }\n        )\n      } else {\n        addToast(`Signing error: ${e.message || e}`, {\n          error: true\n        })\n      }\n    },\n    [account, addToast]\n  )\n\n  const verifySignature = useCallback(\n    (toSign, sig, networkId) => {\n      const provider = getProvider(networkId)\n      return verifyMessage({\n        provider,\n        signer: account.id,\n        message: isTypedData ? null : getMessageAsBytes(toSign.txn),\n        typedData: isTypedData ? dataV4 : null,\n        signature: sig\n      })\n        .then((verificationResult: any) => {\n          if (verificationResult) {\n            addToast(`${toSign.type} SIGNATURE VALID`)\n          } else {\n            addToast(`${toSign.type} SIGNATURE INVALID`, { error: true })\n          }\n        })\n        .catch((e: any) => {\n          addToast(`${toSign.type} SIGNATURE INVALID: ${e.message}`, { error: true })\n        })\n    },\n    [account, addToast, dataV4, isTypedData]\n  )\n\n  const approveQuickAcc = useCallback(\n    async (credentials: any) => {\n      if (!relayerURL) {\n        addToast('Email/pass accounts not supported without a relayer connection', {\n          error: true\n        })\n        return\n      }\n      if (!credentials.password) {\n        addToast('Password required to unlock the account', { error: true })\n        return\n      }\n      setLoading(true)\n      try {\n        const { signature, success, message, confCodeRequired } = await fetchPost(\n          fetch,\n          // network doesn't matter when signing\n          // if it does tho, we can use ${network.id}\n          `${relayerURL}/second-key/${account.id}/ethereum/sign${\n            isTypedData ? '?typedData=true' : ''\n          }`,\n          {\n            toSign: toSign.txn,\n            code: credentials.code?.length ? credentials.code : undefined\n          }\n        )\n        if (!success) {\n          setLoading(false)\n          if (!message) throw new Error('Secondary key: no success but no error message')\n          if (message.includes('invalid confirmation code')) {\n            addToast('Unable to sign: wrong confirmation code', { error: true })\n          }\n          addToast(`Second signature error: ${message}`, {\n            error: true\n          })\n          setConfirmationType(null)\n          setLoading(false)\n\n          return\n        }\n        if (confCodeRequired) {\n          setConfirmationType(confCodeRequired)\n\n          if (onConfirmationCodeRequired) {\n            await onConfirmationCodeRequired(confCodeRequired, approveQuickAcc)\n          }\n\n          setLoading(false)\n          return\n        }\n\n        if (!account.primaryKeyBackup)\n          throw new Error(\n            'No key backup found: you need to import the account from JSON or login again.'\n          )\n        const wallet = await Wallet.fromEncryptedJson(\n          JSON.parse(account.primaryKeyBackup),\n          credentials.password\n        )\n        const sig = await (isTypedData\n          ? signMessage712(\n              wallet,\n              account.id,\n              account.signer,\n              dataV4.domain,\n              dataV4.types,\n              dataV4.message,\n              signature\n            )\n          : signMessage(\n              wallet,\n              account.id,\n              account.signer,\n              getMessageAsBytes(toSign.txn),\n              signature\n            ))\n\n        await verifySignature(toSign, sig, requestedNetwork?.id)\n\n        addToast('Successfully signed!')\n\n        setSignedMessages([\n          ...signedMessages,\n          {\n            accountId: account.id,\n            networkId: requestedChainId,\n            date: new Date().getTime(),\n            typed: isTypedData,\n            signer: account.signer,\n            message: toSign.txn,\n            signature: sig,\n            dApp\n          }\n        ])\n\n        if (everythingToSign.length === 1) {\n          !!onLastMessageSign && onLastMessageSign()\n        }\n\n        // keeping resolve at the very end, because it can trigger components unmounting, and code after resolve may or may not run\n        resolve({ success: true, result: sig })\n      } catch (e) {\n        handleSigningErr(e)\n      }\n      setLoading(false)\n    },\n    [\n      account,\n      addToast,\n      dataV4,\n      everythingToSign,\n      fetch,\n      handleSigningErr,\n      isTypedData,\n      onConfirmationCodeRequired,\n      onLastMessageSign,\n      relayerURL,\n      requestedNetwork,\n      resolve,\n      toSign,\n      verifySignature,\n      dApp,\n      requestedChainId,\n      setSignedMessages,\n      signedMessages\n    ]\n  )\n  // Passing hardware device is required only for the mobile app\n  const approve = useCallback(\n    async (credentials: any, device?: any) => {\n      if (account.signer?.quickAccManager) {\n        await approveQuickAcc(credentials)\n        return\n      }\n      setLoading(true)\n\n      try {\n        const wallet = await getHardwareWallet(device)\n\n        if (!wallet) {\n          return\n        }\n\n        // It would be great if we could pass the full data cause then web3 wallets/hw wallets can display the full text\n        // Unfortunately that isn't possible, because isValidSignature only takes a bytes32 hash; so to sign this with\n        // a personal message, we need to be signing the hash itself as binary data such that we match 'Ethereum signed message:\\n32<hash binary data>' on the contract\n\n        const sig = await (isTypedData\n          ? signMessage712(\n              wallet,\n              account.id,\n              account.signer,\n              dataV4.domain,\n              dataV4.types,\n              dataV4.message\n            )\n          : signMessage(wallet, account.id, account.signer, getMessageAsBytes(toSign.txn)))\n\n        await verifySignature(toSign, sig, requestedNetwork?.id)\n\n        addToast('Successfully signed!')\n\n        setSignedMessages([\n          ...signedMessages,\n          {\n            accountId: account.id,\n            networkId: requestedChainId,\n            date: new Date().getTime(),\n            typed: isTypedData,\n            signer: account.signer,\n            message: toSign.txn,\n            signature: sig,\n            dApp\n          }\n        ])\n\n        // keeping resolve at the very end, because it can trigger components unmounting, and code after resolve may or may not run\n        resolve({ success: true, result: sig })\n      } catch (e) {\n        handleSigningErr(e)\n      }\n      setLoading(false)\n    },\n    [\n      account,\n      addToast,\n      approveQuickAcc,\n      dataV4,\n      getHardwareWallet,\n      handleSigningErr,\n      requestedNetwork?.id,\n      resolve,\n      toSign,\n      isTypedData,\n      verifySignature,\n      signedMessages,\n      setSignedMessages,\n      dApp,\n      requestedChainId\n    ]\n  )\n\n  return {\n    approve,\n    approveQuickAcc,\n    toSign,\n    isLoading,\n    hasPrivileges,\n    hasProviderError,\n    typeDataErr,\n    isDeployed,\n    dataV4,\n    requestedNetwork,\n    requestedChainId,\n    isTypedData,\n    confirmationType,\n    verifySignature,\n    dApp\n  }\n}\n\nexport default useSignMessage\n","import networks from '../../constants/networks'\n\nexport const getNetworkByChainId = (chainId?: string | number) => {\n  if (!chainId) return null\n\n  return networks.find((n) => n.chainId === parseInt(chainId.toString(), 10))\n}\n\nexport const getNetworkById = (id: string | number) => {\n  return networks.find((n) => n.id === id)\n}\n","import useSignMessage from './useSignMessage'\n\nexport default useSignMessage\n","const supportedDApps: string[] = [\n  'https://snapshot.org',\n  'https://guild.xyz',\n  'https://sudoswap.xyz',\n  'https://sigtool.ambire.com/',\n  'https://app.swappin.gifts',\n  'https://app.swappin.gifts/ref/ambire'\n]\n\nexport default supportedDApps\n","import useSignMessage from \"ambire-common/src/hooks/useSignMessage\"\nimport supportedDApps from \"ambire-common/src/constants/supportedDApps\"\n\nimport \"./SignMessage.scss\"\n\nimport { MdBrokenImage, MdCheck, MdClose, MdInfoOutline } from \"react-icons/md\"\nimport { toUtf8String, isHexString } from \"ethers/lib/utils\"\nimport * as blockies from \"blockies-ts\"\nimport { getWallet } from \"lib/getWallet\"\nimport { useToasts } from \"hooks/toasts\"\nimport { useState, useEffect, useRef } from \"react\"\nimport { Button, Loading, TextInput, ToolTip, DAppIncompatibilityWarningMsg } from \"components/common\"\n\nimport useLocalStorage from 'hooks/useLocalStorage'\n\nconst CONF_CODE_LENGTH = 6\n\nexport default function SignMessage({ everythingToSign, resolve, account, relayerURL, totalRequests }) {\n  const defaultState = () => ({ codeRequired: false, passphrase: \"\" })\n  const { addToast } = useToasts()\n  const [signingState, setSigningState] = useState(defaultState())\n  const [promiseResolve, setPromiseResolve] = useState(null)\n  const inputSecretRef = useRef(null)\n\n  const onConfirmationCodeRequired = async (confCodeRequired, approveQuickAcc) => {\n    const confCode = await new Promise((resolve) => {\n      setPromiseResolve(() => resolve)\n    })\n    if (!confCode) throw new Error(\"You must enter a confirmation code\")\n    await approveQuickAcc({\n      password: signingState.passphrase,\n      code: confCode\n    })\n\n    return\n  }\n\n  const getHardwareWallet = () => {\n    // if quick account, wallet = await fromEncryptedBackup\n    // and just pass the signature as secondSig to signMsgHash\n    const wallet = getWallet(\n      {\n        signer: account.signer,\n        signerExtra: account.signerExtra,\n        chainId: 1 // does not matter\n      }\n    )\n\n    return wallet\n  }\n\n  const {\n    approve,\n    toSign,\n    isLoading,\n    hasPrivileges,\n    hasProviderError,\n    typeDataErr,\n    isDeployed,\n    dataV4,\n    requestedNetwork,\n    requestedChainId,\n    isTypedData,\n    confirmationType,\n    dApp\n  } = useSignMessage({\n    fetch,\n    account,\n    everythingToSign,\n    relayerURL,\n    addToast,\n    resolve,\n    onConfirmationCodeRequired,\n    getHardwareWallet,\n    useStorage: useLocalStorage,\n  })\n\n  const isDAppSupported = dApp && (supportedDApps.includes(dApp.url) || supportedDApps.includes(dApp.url+'/'))\n\n  useEffect(() => {\n    if (confirmationType) inputSecretRef.current.focus()\n  }, [confirmationType])\n\n  if (!toSign || !account) return <></>\n\n  // should not happen unless chainId is dropped for some reason in addRequests\n  if (!requestedNetwork) {\n    return (\n      <div id='signMessage'>\n        <h3 className='error'>\n          Inexistant network for chainId : {requestedChainId}\n        </h3>\n        <Button\n          className='reject'\n          onClick={() => resolve({ message: \"signature denied\" })}\n        >\n          Reject\n        </Button>\n      </div>\n    )\n  }\n\n  if (typeDataErr)\n    return (\n      <div id='signMessage'>\n        <h3 className='error'>Invalid signing request: {typeDataErr}</h3>\n        <Button\n          className='reject'\n          onClick={() => resolve({ message: \"signature denied\" })}\n        >\n          Reject\n        </Button>\n      </div>\n    )\n\n  const handleInputConfCode = (e) => {\n    if (e.length === CONF_CODE_LENGTH) promiseResolve(e)\n  }\n\n  const handleSubmit = (e) => {\n    e.preventDefault()\n    approve({\n      password: signingState.passphrase\n    })\n  }\n\n  return (\n    <div id='signMessage'>\n      <div id='signingAccount' className='panel'>\n        <div className='title'>Signing with account</div>\n        <div className='content'>\n          <div className='signingAccount-account'>\n            <img\n              className='icon'\n              src={blockies.create({ seed: account.id }).toDataURL()}\n              alt='Account Icon'\n            />\n            {account.id}\n          </div>\n          <div className='signingAccount-network'>\n            on\n            <div\n              className='icon'\n              style={{ backgroundImage: `url(${requestedNetwork.icon})` }}\n            />\n            <div className='address'>{requestedNetwork.name}</div>\n          </div>\n        </div>\n      </div>\n      <div className='panel'>\n        <div className='title signMessageTitle'>\n          <span className='signMessageTitle-title'>Sign message</span>\n          <span className='signMessageTitle-signatureType'>\n            <ToolTip\n              label={`${\n                isTypedData\n                  ? \"An EIP-712 typed data signature has been requested\"\n                  : \"An ethSign ethereum signature type has been requested\"\n              }`}\n            >\n              <MdInfoOutline />{\" \"}\n              <span>{isTypedData ? \"EIP-712 type\" : \"standard type\"}</span>\n            </ToolTip>\n          </span>\n        </div>\n\n        <div className='request-message'>\n          <div className='dapp-message'>\n            {dApp ? (\n              <a\n                className='dapp'\n                href={dApp.url}\n                target='_blank'\n                rel='noreferrer'\n              >\n                <div\n                  className='icon'\n                  style={{ backgroundImage: `url(${dApp.icons ? dApp.icons[0] : 'none'})` }}\n                >\n                  <MdBrokenImage />\n                </div>\n                {dApp.name}\n              </a>\n            ) : (\n              \"A dApp \"\n            )}\n            is requesting your signature.\n          </div>\n          <span>\n            {totalRequests > 1\n              ? `You have ${totalRequests - 1} more pending requests.`\n              : \"\"}\n          </span>\n          {!isDAppSupported && <DAppIncompatibilityWarningMsg />}\n        </div>\n\n        <textarea\n          className='sign-message'\n          type='text'\n          value={\n            dataV4\n              ? JSON.stringify(dataV4, \"\\n\", \" \")\n              : toSign.txn !== \"0x\"\n              ? getMessageAsText(toSign.txn)\n              : \"(Empty message)\"\n          }\n          readOnly={true}\n        />\n\n        <div className='actions'>\n          <form onSubmit={handleSubmit}>\n            {account.signer.quickAccManager && isDeployed && (\n              <>\n                <TextInput\n                  password\n                  required\n                  minLength={3}\n                  placeholder='Account password'\n                  value={signingState.passphrase}\n                  onChange={(value) =>\n                    setSigningState({ ...signingState, passphrase: value })\n                  }\n                ></TextInput>\n                <input type='submit' hidden />\n              </>\n            )}\n\n            {confirmationType && (\n              <>\n                {confirmationType === \"email\" && (\n                  <span>\n                    A confirmation code has been sent to your email, it is valid\n                    for 3 minutes.\n                  </span>\n                )}\n                {confirmationType === \"otp\" && (\n                  <span>Please enter your OTP code</span>\n                )}\n                <TextInput\n                  ref={inputSecretRef}\n                  placeholder={\n                    confirmationType === \"otp\"\n                      ? \"Authenticator OTP code\"\n                      : \"Confirmation code\"\n                  }\n                  onInput={(value) => handleInputConfCode(value)}\n                />\n              </>\n            )}\n\n            {isDeployed === null && !hasProviderError && (\n              <div>\n                <Loading />\n              </div>\n            )}\n\n            {isDeployed === false && (\n              <div>\n                <h3 className='error'>You can't sign this message yet.</h3>\n                <h3 className='error'>\n                  You need to complete your first transaction on{\" \"}\n                  {requestedNetwork.name} network in order to be able to sign\n                  messages.\n                </h3>\n              </div>\n            )}\n\n            {hasPrivileges === false && (\n              <div>\n                <h3 className='error'>\n                  You do not have the privileges to sign this message.\n                </h3>\n              </div>\n            )}\n\n            {hasProviderError && (\n              <div>\n                <h3 className='error'>\n                  There was an issue with the network provider:{\" \"}\n                  {hasProviderError}\n                </h3>\n              </div>\n            )}\n\n            <div className='buttons'>\n              <Button\n                type='button'\n                danger\n                icon={<MdClose />}\n                className='reject'\n                onClick={() => resolve({ message: \"signature denied\" })}\n              >\n                Reject\n              </Button>\n              {isDeployed !== null && isDeployed && hasPrivileges && (\n                <Button type='submit' className='approve' disabled={isLoading}>\n                  {isLoading ? (\n                    <>\n                      <Loading />\n                      Signing...\n                    </>\n                  ) : (\n                    <>\n                      <MdCheck /> Sign\n                    </>\n                  )}\n                </Button>\n              )}\n            </div>\n          </form>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nfunction getMessageAsText(msg) {\n  if (isHexString(msg)) {\n    try {\n      return toUtf8String(msg)\n    } catch (_) {\n      return msg\n    }\n  }\n  return msg?.toString ? msg.toString() : msg + \"\" //what if dapp sends it as object? force string to avoid app crashing\n}\n","import { Client } from 'gridplus-sdk'\nimport { ethers } from 'ethers'\nimport { serialize } from '@ethersproject/transactions'\n\nconst crypto = require('crypto')\nconst HARDENED_OFFSET = 0x80000000\n\nconst getAddressesReqOpts = {\n    startPath: [\n        HARDENED_OFFSET + 44,\n        HARDENED_OFFSET + 60,\n        HARDENED_OFFSET,\n        0,\n        0,\n    ],\n    n: 10,\n}\n\nconst latticeInit = commKey => {\n    const clientConfig = {\n        name: 'Ambire Wallet',\n        crypto: crypto,\n        privKey: commKey,\n    }\n\n    return new Client(clientConfig)\n}\n\nconst latticeConnect = async(client, deviceId) => {\n    return await new Promise((resolve, reject) => {\n        client.connect(deviceId, (err, isPaired) => {\n            if (err) {\n                reject(`Lattice connect: ${err} Or check if the DeviceID is correct.`)\n                return\n            }\n            \n            resolve({ isPaired: !!isPaired, errConnect: false })\n        })\n    }).catch(err => {\n        console.error(err)\n        return { isPaired: false, errConnect: err }\n    })\n}\n\nconst latticePair = async(client, secret) => {\n    return await new Promise((resolve, reject) => {\n        client.pair(secret, (err, hasActiveWallet) => {\n            if (err) {\n                reject(`Lattice connect: ${err}`)\n                return\n            }\n            \n            resolve({ hasActiveWallet, errPair: false })\n        })\n    }).catch(err => {\n        console.error(err)\n        return { hasActiveWallet: false, errPair: err }\n    })\n}\n\nconst latticeGetAddresses = async client => {\n    return await new Promise((resolve, reject) => {\n        client.getAddresses(getAddressesReqOpts, (err, res) => {\n            if (err) {\n                reject(`Lattice get addresses: ${err}`)\n                return\n            }\n\n            if (!res) throw new Error('Lattice could not get the addresses.')\n\n            resolve({res, errGetAddresses: false })\n        })\n    }).catch(err => {\n        console.error(err)\n        return { res: null, errGetAddresses: err }\n    })\n}\n\nconst latticeSignMessage = async(client, hash) => {\n    const dataMsg = {\n        protocol: 'signPersonal',\n        payload: ethers.utils.hexlify(hash),\n        signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, 0],\n    }\n\n    const signOptsMsg = {\n        currency: 'ETH_MSG',\n        data: dataMsg,\n    }\n\n    \n    return await new Promise((resolve, reject) => {\n        client.sign(signOptsMsg, (err, signedTx) => {\n            if (err) {\n                reject(err)\n                return\n            }\n\n            if (!signedTx) throw new Error('Lattice could not sign the message.')\n            \n            resolve({ signedMsg: '0x' + signedTx.sig.r + signedTx.sig.s + signedTx.sig.v[0].toString(16), errSignMessage: false })  \n        })\n    }).catch(err => {\n        console.error(err)\n        return { signedMsg: null, errSignMessage: err }\n    })\n}\n\nconst latticeSignMessage712 = async(client, message) => {\n    const reqData = {\n        currency: 'ETH_MSG',\n        data: {\n          signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, 0],\n          protocol: 'eip712', // You must use this string to specify this protocol\n          payload: message\n        }\n      }\n\n    return await new Promise((resolve, reject) => {\n        client.sign(reqData, (err, signedTx) => {\n            if (err) {\n                reject(err)\n                return\n            }\n\n            if (!signedTx) throw new Error('Lattice could not sign the message.')\n            \n            resolve({ signedMsg: '0x' + signedTx.sig.r + signedTx.sig.s + signedTx.sig.v[0].toString(16), errSignMessage: false })  \n        })\n    }).catch(err => {\n        console.error(err)\n        return { signedMsg: null, errSignMessage: err }\n    })\n}\n\nconst latticeSignTransaction = async(client, txn, chainId) => {\n    const { to, data, gas, gasPrice, nonce, value = 0 } = txn\n    const unsignedTxObj = {\n        ...txn,\n        gasLimit: txn.gasLimit || txn.gas,\n        chainId\n    }\n    delete unsignedTxObj.from\n    delete unsignedTxObj.gas\n\n    const txData = {\n        nonce,\n        gasLimit: gas || txn.gasLimit,\n        gasPrice,\n        to,\n        value,\n        data: data || '',\n        // -- m/44'/60'/0'/0/0\n        signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, 0],\n        chainId,\n        useEIP155: true,\n    }\n\n    const signOpts = {\n        currency: 'ETH',\n        data: txData,\n    }\n\n    \n    return await new Promise((resolve, reject) => {\n        client.sign(signOpts, (err, signedTx) => {\n            if (err) {\n                reject(err)\n                return\n            }\n\n            if (!signedTx) throw new Error('Lattice could not sign the message.')\n            \n            delete unsignedTxObj.v\n            const serializedSigned = serialize(unsignedTxObj, {\n                r: '0x' + signedTx.sig.r,\n                s: '0x' + signedTx.sig.s,\n                v: signedTx.sig.v[0].toString(16)\n            })\n            \n            resolve({ serializedSigned, errSignTxn: false })\n        })\n    }).catch(err => {\n        console.error(err)\n        return { serializedSigned: null, errSignTxn: err }\n    })\n}\n\nexport { \n    latticeInit,\n    latticeConnect,\n    latticePair,\n    latticeGetAddresses,\n    latticeSignMessage,\n    latticeSignMessage712,\n    latticeSignTransaction\n }\n","import TransportWebHID from '@ledgerhq/hw-transport-webhid'\nimport AppEth from '@ledgerhq/hw-app-eth'\nimport { serialize } from '@ethersproject/transactions'\n\nconst EIP_155_CONSTANT = 35\n\nconst ethUtil = require('ethereumjs-util')\nconst HDNode = require('hdkey')\n\nlet connectedDevices = null\n\nexport const PARENT_HD_PATH = \"44'/60'/0'/0\"\n\nasync function getTransport() {\n  connectedDevices = await TransportWebHID.list()\n  if (connectedDevices.length) {\n    if (connectedDevices[0].opened) {\n      return new TransportWebHID(connectedDevices[0])\n    } else { // when transport is still not closed and time between 2 requests is short\n      return TransportWebHID.open(connectedDevices[0])\n    }\n  } else {\n    try {\n      return await TransportWebHID.request()\n    } catch (e) {\n      if (e.message.includes('reading \\'open\\'')) {\n        throw new Error('ledger WebHID request denied')\n      }\n      throw new Error('Could not request WebHID ledger: ' + e.message)\n    }\n  }\n}\n\nexport async function ledgerGetAddresses() {\n  const transport = await getTransport()\n  const accounts = await getAccounts(transport)\n  transport.close()\n\n  return accounts.map(a => a.address)\n}\n\nasync function getAccounts(transport) {\n  const parentKeyDerivationPath = `m/${PARENT_HD_PATH}`\n  let ledgerResponse\n  ledgerResponse = await getAddressInternal(transport, parentKeyDerivationPath).then(o => o).catch(err => {\n    if (err.statusCode === 25871 || err.statusCode === 27404) {\n      throw Error('Please make sure your ledger is unlocked and running the Ethereum app. ' + err.message)\n    } else {\n      throw Error('Could not get address from ledger : ' + err)\n    }\n  })\n\n  const hdKey = new HDNode()\n  hdKey.publicKey = Buffer.from(ledgerResponse.publicKey, 'hex')\n  hdKey.chainCode = Buffer.from(ledgerResponse.chainCode, 'hex')\n  const mainAddress = addressOfHDKey(hdKey)\n\n  const initialDerivedKeyInfo = {\n    hdKey,\n    address: mainAddress,\n    derivationPath: parentKeyDerivationPath,\n    baseDerivationPath: PARENT_HD_PATH,\n  }\n\n  // currently we can't get addrs to match with what appears in MM/Ledger live so only one is derived\n  return calculateDerivedHDKeyInfos(initialDerivedKeyInfo, 1)\n}\n\n\nasync function getAddressInternal(transport, parentKeyDerivationPath) {\n  let timeoutHandle\n  const appEth = new AppEth(transport)\n\n  const ledgerTimeout = new Promise((resolve, reject) => {\n    timeoutHandle = setTimeout(() => {\n      return reject(new Error('Device took too long to respond...'))\n    }, 10000)\n  })\n\n  return Promise.race([\n    appEth.getAddress(parentKeyDerivationPath, false, true),\n    ledgerTimeout\n  ]).then((res) => {\n    clearTimeout(timeoutHandle)\n    return res\n  })\n}\n\nexport async function ledgerSignTransaction(txn, chainId) {\n  const transport = await getTransport()\n\n  const fromAddr = txn.from\n\n  const unsignedTxObj = {\n    ...txn,\n    gasLimit: txn.gasLimit || txn.gas,\n    chainId: chainId\n  }\n  delete unsignedTxObj.from\n  delete unsignedTxObj.gas\n\n  let serializedUnsigned = serialize(unsignedTxObj)\n  const accountsData = await getAccounts(transport)\n\n  //Managing only 1 addr for now\n  const address = accountsData[0].address\n\n  let serializedSigned\n  if (address.toLowerCase() === fromAddr.toLowerCase()) {\n    let rsvResponse\n    try {\n      rsvResponse = await new AppEth(transport).signTransaction(accountsData[0].derivationPath, serializedUnsigned.substr(2))\n    } catch (e) {\n      throw new Error('Could not sign transaction ' + e)\n    }\n\n    const intV = parseInt(rsvResponse.v, 16)\n    const signedChainId = Math.floor((intV - EIP_155_CONSTANT) / 2)\n\n    if (signedChainId !== chainId) {\n      throw new Error('Invalid returned V 0x' + rsvResponse.v)\n    }\n\n    delete unsignedTxObj.v\n    serializedSigned = serialize(unsignedTxObj, {\n      r: '0x' + rsvResponse.r,\n      s: '0x' + rsvResponse.s,\n      v: intV\n    })\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n\n  transport.close()\n\n  return serializedSigned\n}\n\nexport async function ledgerSignMessage(hash, signerAddress) {\n  const transport = await getTransport()\n\n  const accountsData = await getAccounts(transport)\n\n  //TODO for multiple accs?\n  const account = accountsData[0]\n\n  let signedMsg\n  if (account.address.toLowerCase() === signerAddress.toLowerCase()) {\n    try {\n      const rsvReply = await new AppEth(transport).signPersonalMessage(account.derivationPath, hash.substr(2))\n      signedMsg = '0x' + rsvReply.r + rsvReply.s + rsvReply.v.toString(16)\n    } catch (e) {\n      throw new Error('Signature denied ' + e.message)\n    }\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n  transport.close()\n  return signedMsg\n}\n\nexport async function ledgerSignMessage712(domainSeparator, hashStructMessage, signerAddress) {\n  const transport = await getTransport()\n\n  const accountsData = await getAccounts(transport)\n\n  //TODO for multiple accs?\n  const account = accountsData[0]\n\n  let signedMsg\n  if (account.address.toLowerCase() === signerAddress.toLowerCase()) {\n    try {\n      const rsvReply = await new AppEth(transport).signEIP712HashedMessage(account.derivationPath, domainSeparator, hashStructMessage)\n      signedMsg = '0x' + rsvReply.r + rsvReply.s + rsvReply.v.toString(16)\n    } catch (e) {\n      throw new Error('Signature denied ' + e.message)\n    }\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n  transport.close()\n  return signedMsg\n}\n\nfunction calculateDerivedHDKeyInfos(initialDerivedKeyInfo, count) {\n  const derivedKeys = []\n  for (let i = 0; i < count; i++) {\n\n    const fullDerivationPath = `m/${initialDerivedKeyInfo.baseDerivationPath}/${i}`\n    const path = `m/${i}`\n    const hdKey = initialDerivedKeyInfo.hdKey.derive(path)\n    const address = addressOfHDKey(hdKey)\n    const derivedKey = {\n      address,\n      hdKey,\n      baseDerivationPath: initialDerivedKeyInfo.baseDerivationPath,\n      derivationPath: fullDerivationPath,\n    }\n\n    derivedKeys.push(derivedKey)\n  }\n  return derivedKeys\n}\n\nexport function addressOfHDKey(hdKey) {\n  const shouldSanitizePublicKey = true\n  const derivedPublicKey = hdKey.publicKey\n  const ethereumAddressUnprefixed = ethUtil\n    .publicToAddress(derivedPublicKey, shouldSanitizePublicKey)\n    .toString('hex')\n  return ethUtil.addHexPrefix(ethereumAddressUnprefixed).toLowerCase()\n}\n","import { TrezorSubprovider } from '@0x/subproviders/lib/src/subproviders/trezor' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport TrezorConnect from '@trezor/connect-web'\nimport { ethers } from 'ethers'\nimport HDNode from 'hdkey'\nimport { LedgerSubprovider } from '@0x/subproviders/lib/src/subproviders/ledger' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport { ledgerEthereumBrowserClientFactoryAsync } from '@0x/subproviders/lib/src' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport { ledgerSignMessage, ledgerSignTransaction, ledgerSignMessage712, ledgerGetAddresses } from './ledgerWebHID'\nimport { \n  latticeInit, \n  latticeConnect, \n  latticeSignMessage, \n  latticeSignTransaction, \n  latticeGetAddresses, \n  latticeSignMessage712\n } from 'lib/lattice'\nimport { _TypedDataEncoder } from 'ethers/lib/utils'\nimport { getProvider } from 'lib/provider'\nimport networks from 'consts/networks'\n\nlet wallets = {}\n\n// opts\n// passphrase: string\n// noCache: boolean\nexport function getWallet({ signer, signerExtra, chainId }, opts = {}) {\n  const id = `${signer.address || signer.one}${chainId}`\n  if (wallets[id]) return wallets[id]\n  return wallets[id] = getWalletNew({ signer, signerExtra, chainId }, opts)\n}\n\nfunction getWalletNew({ chainId, signer, signerExtra }, opts) {\n  if (signerExtra && signerExtra.type === 'trezor') {\n    TrezorConnect.manifest({\n      email: 'contactus@ambire.com',\n      appUrl: 'https://wallet.ambire.com'\n    })\n    const providerTrezor = new TrezorSubprovider({\n      trezorConnectClientApi: TrezorConnect,\n      networkId: chainId\n    })\n    providerTrezor._initialDerivedKeyInfo = getInitialDerivedKeyInfo(signerExtra)\n    // for Trezor/ledger, alternatively we can shim using https://www.npmjs.com/package/web3-provider-engine and then wrap in Web3Provider\n    return {\n      signMessage: hash => providerTrezor.signPersonalMessageAsync(ethers.utils.hexlify(hash), signer.address),\n      signTransaction: params => providerTrezor.signTransactionAsync({ ...params, from: signer.address }),\n      sendTransaction: async (transaction) => {\n        const network = networks.find(n => n.chainId === transaction.chainId)\n        if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n        const broadcastProvider = await getProvider(network.id)\n        if (!broadcastProvider) throw Error('no provider found for network : ' + network.id)\n\n        transaction.nonce = ethers.utils.hexlify(await broadcastProvider.getTransactionCount(transaction.from))\n        const gas = ethers.utils.hexlify(transaction.gas || transaction.gasLimit)\n        transaction.gasPrice = ethers.utils.hexlify(transaction.gasPrice)\n        \n        transaction = {\n          ...transaction,\n          gas // trezor params requires gas prop\n          // no chainId prop but chainId already known by providerTrezor\n        }\n        \n        const signedTx = await providerTrezor.signTransactionAsync(transaction)\n        \n        return broadcastProvider.sendTransaction(signedTx)\n      },\n      isConnected: async (matchAddress) => { // chain is provided to trezor. Not necessary to check network\n        const addresses = await providerTrezor.getAccountsAsync(100)\n        return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n      },\n      _signTypedData: async (domain, types, value) => {\n        \n        const domainSeparator = _TypedDataEncoder.hashDomain(domain)\n        const hashStructMessage = _TypedDataEncoder.hashStruct(_TypedDataEncoder.getPrimaryType(types), types, value)\n        const data = _TypedDataEncoder.getPayload(domain, types, value)\n        const initialDerivedKeyInfo = await providerTrezor._initialDerivedKeyInfoAsync()\n        const derivedKeyInfo = providerTrezor._findDerivedKeyInfoForAddress(initialDerivedKeyInfo, signer.address)\n        const path = derivedKeyInfo.derivationPath\n\n        const response = await providerTrezor._trezorConnectClientApi.ethereumSignTypedData({\n          path,\n          data,\n          metamask_v4_compat: true,\n          domain_separator_hash: domainSeparator,\n          message_hash: hashStructMessage\n        })\n\n        if (response.success) {\n          return `${response.payload.signature}`;\n        } else {\n            throw new Error(response.payload.error);\n        }\n      }\n    }\n  } else if (signerExtra && signerExtra.type === 'ledger') {\n    if (signerExtra.transportProtocol === 'webHID') {\n      return {\n        signMessage: hash => ledgerSignMessage(ethers.utils.hexlify(hash), signer.address),\n        signTransaction: params => ledgerSignTransaction(params, chainId),\n        sendTransaction: async (transaction) => {\n          const network = networks.find(n => n.chainId === transaction.chainId)\n          if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n          const provider = await getProvider(network.id)\n          if (!provider) throw Error('no provider found for network : ' + network.id)\n\n          transaction.nonce = ethers.utils.hexlify(await provider.getTransactionCount(transaction.from))\n\n          const signedTx = await ledgerSignTransaction(transaction, transaction.chainId)\n\n          return provider.sendTransaction(signedTx)\n        },\n        isConnected: async (matchAddress) => { // chain is provided to ledger. Not necessary to check network\n          const addresses = await ledgerGetAddresses()\n          if (addresses && addresses[0]) {\n            if (matchAddress) {\n              return !!addresses.find(a => a.toLowerCase() === matchAddress.toLowerCase())\n            }\n            return true\n          }\n          return false\n        },\n        _signTypedData: (domain, types, value) => {\n          const domainSeparator = _TypedDataEncoder.hashDomain(domain)\n          const hashStructMessage = _TypedDataEncoder.hashStruct(_TypedDataEncoder.getPrimaryType(types), types, value)\n          return ledgerSignMessage712(domainSeparator, hashStructMessage, signer.address)\n        }\n      }\n    } else {\n      const provider = new LedgerSubprovider({\n        networkId: chainId,\n        ledgerEthereumClientFactoryAsync: ledgerEthereumBrowserClientFactoryAsync,\n        baseDerivationPath: signerExtra.info.baseDerivationPath\n      })\n      return {\n        signMessage: hash => provider.signPersonalMessageAsync(ethers.utils.hexlify(hash), signer.address),\n        signTransaction: params => provider.signTransactionAsync({ ...params, from: signer.address }),\n        sendTransaction: async () => {\n          throw Error('Please use a chrome based browser to use Ledger')\n        },\n        isConnected: async (matchAddress) => { // chain is provided to ledger. Not necessary to check network\n          const addresses = await provider.getAccountsAsync(1)\n          return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n        },\n        _signTypedData: (domain, types, value) => {\n          throw Error('Please, use a chrome based browser to use 721 Typed signatures')\n        }\n      }\n    }\n  } else if (signerExtra && signerExtra.type === 'Lattice') {\n    return {\n      signMessage: async hash => {\n        return await wrapLatticeError(async hash => {\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { signedMsg, errSignMessage } = await latticeSignMessage(client, hash)\n          if (errSignMessage) throw new Error(errSignMessage)\n\n          return signedMsg\n        }, [hash])\n      },\n      signTransaction: async params => {\n        return await wrapLatticeError( async params => {\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { serializedSigned, errSignTxn } = await latticeSignTransaction(client, params, chainId)\n          if (errSignTxn) throw new Error(errSignTxn)\n\n          return serializedSigned\n        }, [params])\n      },\n      sendTransaction: async transaction => { \n        return await wrapLatticeError(async (transaction) => {\n          const network = networks.find(n => n.chainId === transaction.chainId)\n          if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n          const broadcastProvider = await getProvider(network.id)\n          if (!broadcastProvider) throw Error('no provider found for network : ' + network.id)\n          transaction.nonce = ethers.utils.hexlify(await broadcastProvider.getTransactionCount(transaction.from))\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const { isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { serializedSigned, errSignTxn } = await latticeSignTransaction(client, transaction, chainId)\n          if (errSignTxn) throw new Error(errSignTxn)\n\n          return broadcastProvider.sendTransaction(serializedSigned)\n        }, [transaction])\n      },\n      isConnected: async matchAddress => { \n        return await wrapLatticeError(async (matchAddress) => {\n          let addresses = null\n\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const { isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { res, errGetAddresses } = await latticeGetAddresses(client)\n          if (errGetAddresses) { \n            throw new Error(`Lattice: ${errGetAddresses}`, { error: true })\n          }\n\n          addresses = res\n          return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n        }, [matchAddress])\n    },\n    _signTypedData: async (domain, types, value) => {\n      return await wrapLatticeError(async (domain, types, value) => {\n        const payload = _TypedDataEncoder.getPayload(domain, types, value)\n        const { commKey, deviceId } = signerExtra\n        const client = latticeInit(commKey)\n        const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n        if (errConnect) throw new Error(errConnect.message || errConnect)\n\n        if (!isPaired) {\n          // Canceling the visualization of the secret code on the device's screen.\n          client.pair('')\n          throw new Error('The Lattice device is not paired! Please re-add your account!')\n        }\n\n        const { signedMsg, errSignMessage } = await latticeSignMessage712(client, payload)\n        if (errSignMessage) throw new Error(errSignMessage)\n\n        return signedMsg\n      }, [domain, types, value])\n    }\n  }\n  } else if (signer.address) {\n    if (!window.ethereum) throw new Error('No web3 support detected in your browser: if you created this account through MetaMask, please install it.')\n    // NOTE: for metamask, use `const provider = new ethers.providers.Web3Provider(window.ethereum)`\n    // 'any' is explained here: https://github.com/ethers-io/ethers.js/issues/1107\n    const provider = new ethers.providers.Web3Provider(window.ethereum, 'any')\n\n    const signerObject = provider.getSigner(signer.address)\n\n    signerObject.isConnected = async (matchAddress, matchChain) => {\n      const accounts = await provider.listAccounts()\n\n      let match = true\n      if (!!(accounts.length)) {\n        if (matchAddress) {\n          match = !!accounts.find(a => a.toLowerCase() === matchAddress.toLowerCase())\n        }\n        if (matchChain) {\n          const { chainId } = await provider.getNetwork()\n          match = match && chainId === matchChain\n        }\n      } else {\n        match = false\n      }\n      return match\n    }\n\n    return signerObject\n  } else if (signer.one) {\n    throw new Error('getWallet not applicable for QuickAccounts: use primaryKeyBackup with the passphrase and /second-sig')\n  } else {\n    throw new Error('unknown signer type')\n  }\n}\n\nfunction getInitialDerivedKeyInfo(signerExtra) {\n  return {\n    hdKey: HDNode.fromExtendedKey(signerExtra.info.hdKey.xpub),\n    derivationPath: signerExtra.info.derivationPath,\n    baseDerivationPath: signerExtra.info.baseDerivationPath\n  }\n}\n\nasync function wrapLatticeError(fn, arg) {\n  return await fn.apply(this, arg)\n   .catch(e => {\n     throw new Error(`Lattice: ${e.message}`)\n    })\n}\n"],"sourceRoot":""}