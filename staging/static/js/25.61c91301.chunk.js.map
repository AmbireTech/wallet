{"version":3,"sources":["../node_modules/@ambire/signature-validator/index.js","../node_modules/ambire-common/src/hooks/useSignMessage/useSignMessage.ts","../node_modules/ambire-common/src/services/getNetwork/getNetwork.ts","../node_modules/ambire-common/src/hooks/useSignMessage/index.ts","../node_modules/ambire-common/src/constants/supportedDApps.ts","components/SignMessage/SignMessage.js"],"names":["ethers","require","VALIDATOR_1271_ABI","verifyMessage","provider","signer","message","typedData","finalDigest","signature","undeployedCallback","utils","hashMessage","domain","types","Error","_TypedDataEncoder","hash","addrMatching","recoverAddress","eip1271Check","recoveredAddr","targetAddr","isAddress","toLowerCase","web3CompatibleProvider","ethersProvider","providers","Provider","isProvider","Web3Provider","getCode","code","contract","Contract","isValidSignature","module","exports","getMessageAsBytes","msg","isHexString","arrayify","toUtf8Bytes","useSignMessage","typeDataErr","dataV4","fetch","account","everythingToSign","relayerURL","addToast","resolve","onConfirmationCodeRequired","onLastMessageSign","getHardwareWallet","useStorage","useState","isLoading","setLoading","isDeployed","setIsDeployed","hasPrivileges","setHasPrivileges","hasProviderError","setHasProviderError","confirmationType","setConfirmationType","toSign","useMemo","key","defaultValue","signedMessages","setSignedMessages","dApp","dapp","requestedChainId","chainId","isTypedData","indexOf","type","txn","startsWith","JSON","parse","error","EIP712Domain","requestedNetwork","networks","find","n","parseInt","toString","checkIsDeployedAndHasPrivileges","useCallback","a","bundle","Bundle","network","id","identity","getProvider","quickAccManager","quickAccTimelock","accountPresets","quickAccountTuple","one","two","abiCoder","AbiCoder","quickAccAccountHash","keccak256","encode","privilegeAddress","address","callObject","method","params","to","data","substring","jsonrpc","fetchPost","connection","url","then","result","catch","err","useEffect","handleSigningErr","e","includes","verifySignature","sig","networkId","verificationResult","approveQuickAcc","credentials","password","length","undefined","success","confCodeRequired","primaryKeyBackup","Wallet","fromEncryptedJson","wallet","signMessage712","signMessage","accountId","date","Date","getTime","typed","approve","device","supportedDApps","SignMessage","totalRequests","useToasts","codeRequired","passphrase","signingState","setSigningState","promiseResolve","setPromiseResolve","inputSecretRef","useRef","Promise","confCode","getWallet","signerExtra","useLocalStorage","isDAppSupported","current","focus","className","onClick","src","blockies","seed","toDataURL","alt","style","backgroundImage","icon","name","label","href","target","rel","icons","value","stringify","getMessageAsText","readOnly","onSubmit","preventDefault","required","minLength","placeholder","onChange","hidden","ref","onInput","danger","disabled","toUtf8String","_"],"mappings":"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","file":"static/js/25.61c91301.chunk.js","sourcesContent":["const { ethers } = require('ethers')\n\nconst VALIDATOR_1271_ABI = ['function isValidSignature(bytes32 hash, bytes signature) view returns (bytes4)']\n\n/**\n * @typedef { import(\"@ethersproject/abstract-signer\").TypedDataDomain } TypedDataDomain\n * @typedef { import(\"@ethersproject/abstract-signer\").TypedDataField } TypedDataField\n * @typedef { import(\"@ethersproject/providers\").Provider } Provider\n */\n\n/**\n * @param {Provider | window.ethereum} provider Web3 Compatible provider to perform smart contract wallet validation with EIP 1271 (window.ethereum, web3.currentProvider, ethers provider... )\n * @param {string} signer The signer address to verify the signature against\n * @param {string | Uint8Array} message To verify eth_sign type of signatures. Human-readable message to verify. Message should be a human string or the hex version of the human string encoded as Uint8Array. If a hex string is passed, it will be considered as a regular string\n * @param {{domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>}} typedData To verify a 712 signature type. The {domain, type, message} 712 message object\n * @param {string} finalDigest The final digest to verify. dApp will have to pre-compute the hash as no hashing transformation will occur and this digest will be directly used for recoverAddress and isValidSignature\n * @param {string | Uint8Array} signature The signature to verify as a hex string or Uint8Array\n * @param {function(string, string, string | Uint8Array): boolean} undeployedCallback An optional 1271 callback function to gracefully handle signature validation for non-deployed smart contract wallets\n * @returns {Promise<boolean>}\n * NOTE: you only need to pass one of: typedData, finalDigest, message\n */\nconst  verifyMessage = async ({ provider, signer, message, typedData, finalDigest, signature, undeployedCallback }) => {\n  if (message) {\n    finalDigest = ethers.utils.hashMessage(message)\n  } else if (typedData) {\n    if (!typedData.domain || !typedData.types || !typedData.message) {\n      throw Error('Missing one or more properties for typedData (domain, types, message)')\n    }\n\n    finalDigest = ethers.utils._TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message)\n  } else if (!finalDigest) {\n    throw Error('Missing one of the properties: message, unPrefixedMessage, typedData or finalDigest')\n  }\n\n  // First try: elliptic curve signature (EOA)\n  if (addrMatching(recoverAddress(finalDigest, signature), signer)) return true\n\n  // 2nd try: Getting code from deployed smart contract to call 1271 isValidSignature\n  if ((await eip1271Check(provider, signer, finalDigest, signature)) === '0x1626ba7e') return true\n\n  // Last attempt, for undeployed smart contract with custom logic\n  if (undeployedCallback) {\n    try {\n      if (undeployedCallback(signer, finalDigest, signature)) return true\n    } catch (e) {\n      throw new Error('undeployedCallback error: ' + e.message)\n    }\n  }\n\n  return false\n}\n\n// Address recovery wrapper\nconst recoverAddress = (hash, signature) => {\n  try {\n    return ethers.utils.recoverAddress(hash, signature);\n  } catch {\n    return false\n  }\n}\n\n// Comparing addresses. targetAddr is already checked upstream\nconst addrMatching = (recoveredAddr, targetAddr) => {\n  if (recoveredAddr === false) return false\n  if (!ethers.utils.isAddress(recoveredAddr)) throw new Error('Invalid recovered address: ' + recoveredAddr)\n\n  return recoveredAddr.toLowerCase() === targetAddr.toLowerCase()\n}\n\n// EIP 1271 check\nconst eip1271Check = async (web3CompatibleProvider, signer, hash, signature) => {\n  let ethersProvider\n  if (ethers.providers.Provider.isProvider(web3CompatibleProvider)) {\n    ethersProvider = web3CompatibleProvider\n  } else {\n    ethersProvider = new ethers.providers.Web3Provider(web3CompatibleProvider);\n  }\n  const code = await ethersProvider.getCode(signer)\n  if (code && code !== '0x') {\n    const contract = new ethers.Contract(signer, VALIDATOR_1271_ABI, ethersProvider)\n    return contract.isValidSignature(hash, signature)\n  }\n  return false\n}\n\nmodule.exports = {\n  verifyMessage\n}\n","// @ts-nocheck TODO: Fill in all missing types before enabling the TS check again\nimport { Bundle, signMessage, signMessage712 } from 'adex-protocol-eth/js/Bundle'\nimport { Wallet } from 'ethers'\nimport {\n  _TypedDataEncoder,\n  AbiCoder,\n  arrayify,\n  isHexString,\n  keccak256,\n  toUtf8Bytes\n} from 'ethers/lib/utils'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\n\nimport { verifyMessage } from '@ambire/signature-validator'\n\nimport accountPresets from '../../constants/accountPresets'\nimport { fetchPost } from '../../services/fetch'\nimport { getNetworkByChainId } from '../../services/getNetwork'\nimport { getProvider } from '../../services/provider'\nimport { UseSignMessageProps, UseSignMessageReturnType } from './types'\n\nfunction getMessageAsBytes(msg: string) {\n  // Transforming human message / hex string to bytes\n  if (!isHexString(msg)) {\n    return toUtf8Bytes(msg)\n  }\n  return arrayify(msg)\n}\n\nconst useSignMessage = ({\n  fetch,\n  account,\n  everythingToSign,\n  relayerURL,\n  addToast,\n  resolve,\n  onConfirmationCodeRequired,\n  onLastMessageSign,\n  getHardwareWallet,\n  useStorage\n}: UseSignMessageProps): UseSignMessageReturnType => {\n  const [isLoading, setLoading] = useState<boolean>(false)\n  const [isDeployed, setIsDeployed] = useState<null | boolean>(null)\n  const [hasPrivileges, setHasPrivileges] = useState<null | boolean>(null)\n  const [hasProviderError, setHasProviderError] = useState(null)\n  const [confirmationType, setConfirmationType] = useState<'email' | 'otp' | null>(null)\n\n  const toSign = useMemo(() => everythingToSign[0] || {}, [everythingToSign])\n\n  const [signedMessages, setSignedMessages] = useStorage({\n    key: 'signedMessages',\n    defaultValue: []\n  })\n\n  const dApp = toSign.dapp\n\n  let typeDataErr\n  let dataV4: any\n  let requestedChainId = toSign.chainId\n  const isTypedData = ['eth_signTypedData_v4', 'eth_signTypedData'].indexOf(toSign?.type) !== -1\n  if (isTypedData) {\n    dataV4 = toSign.txn\n    try {\n      if (dataV4.startsWith('{')) {\n        dataV4 = JSON.parse(toSign.txn)\n      }\n    } catch (error) {\n      dataV4 = toSign.txn\n    }\n    if (typeof dataV4 === 'object' && dataV4 !== null) {\n      try {\n        if (dataV4?.types?.EIP712Domain) {\n          // Avoids failure in case some dapps explicitly add this (redundant) prop\n          delete dataV4?.types?.EIP712Domain\n        }\n        _TypedDataEncoder.hash(dataV4?.domain, dataV4.types, dataV4?.message)\n        // enforce chainId\n        if (dataV4.domain?.chainId) {\n          requestedChainId = dataV4.domain?.chainId\n        }\n      } catch {\n        typeDataErr = '.txn has Invalid TypedData object. Should be {domain, types, message}'\n      }\n    } else {\n      typeDataErr = '.txn should be a TypedData object'\n    }\n  }\n\n  const requestedNetwork = getNetworkByChainId(requestedChainId)\n\n  const checkIsDeployedAndHasPrivileges = useCallback(async () => {\n    if (!requestedNetwork) return\n\n    const bundle = new Bundle({\n      network: requestedNetwork?.id,\n      identity: account?.id,\n      signer: account?.signer\n    })\n\n    const provider = await getProvider(requestedNetwork?.id)\n\n    let privilegeAddress: any\n    let quickAccAccountHash: any\n    if (account?.signer?.quickAccManager) {\n      const { quickAccTimelock } = accountPresets\n      const quickAccountTuple = [quickAccTimelock, account?.signer?.one, account?.signer?.two]\n      const abiCoder = new AbiCoder()\n      quickAccAccountHash = keccak256(\n        abiCoder.encode(['tuple(uint, address, address)'], [quickAccountTuple])\n      )\n      privilegeAddress = account.signer?.quickAccManager\n    } else {\n      privilegeAddress = account.signer?.address\n    }\n\n    // to differenciate reverts and network issues\n    const callObject = {\n      method: 'eth_call',\n      params: [\n        {\n          to: bundle.identity,\n          data: `0xc066a5b1000000000000000000000000${privilegeAddress.toLowerCase().substring(2)}`\n        },\n        'latest'\n      ],\n      id: 1,\n      jsonrpc: '2.0'\n    }\n\n    fetchPost(fetch, provider?.connection?.url, callObject)\n      .then((result: any) => {\n        if (result.result && result.result !== '0x') {\n          setIsDeployed(true)\n          if (account?.signer?.quickAccManager) {\n            setHasPrivileges(result.result === quickAccAccountHash)\n          } else {\n            // TODO: To ask : in what cases it's more than 1?\n            // eslint-disable-next-line no-lonely-if\n            if (\n              result.result === '0x0000000000000000000000000000000000000000000000000000000000000001'\n            ) {\n              setHasPrivileges(true)\n            } else {\n              setHasPrivileges(false)\n            }\n          }\n        } else {\n          // result.error or anything else that does not have a .result prop, we assume it is not deployed\n          setIsDeployed(false)\n        }\n      })\n      .catch((err) => {\n        // as raw XHR calls, reverts are not caught, but only have .error prop\n        // this should be a netowrk error\n        setHasProviderError(err.message)\n      })\n  }, [account, requestedNetwork, fetch])\n\n  useEffect(() => {\n    checkIsDeployedAndHasPrivileges()\n  }, [checkIsDeployedAndHasPrivileges])\n\n  const handleSigningErr = useCallback(\n    (e: any) => {\n      if (e && e.message.includes('must provide an Ethereum address')) {\n        addToast(\n          `Signing error: not connected with the correct address. Make sure you're connected with ${account.signer?.address}.`,\n          { error: true }\n        )\n      } else {\n        addToast(`Signing error: ${e.message || e}`, {\n          error: true\n        })\n      }\n    },\n    [account, addToast]\n  )\n\n  const verifySignature = useCallback(\n    (toSign, sig, networkId) => {\n      const provider = getProvider(networkId)\n      return verifyMessage({\n        provider,\n        signer: account.id,\n        message: isTypedData ? null : getMessageAsBytes(toSign.txn),\n        typedData: isTypedData ? dataV4 : null,\n        signature: sig\n      })\n        .then((verificationResult: any) => {\n          if (verificationResult) {\n            addToast(`${toSign.type} SIGNATURE VALID`)\n          } else {\n            addToast(`${toSign.type} SIGNATURE INVALID`, { error: true })\n          }\n        })\n        .catch((e: any) => {\n          addToast(`${toSign.type} SIGNATURE INVALID: ${e.message}`, { error: true })\n        })\n    },\n    [account, addToast, dataV4, isTypedData]\n  )\n\n  const approveQuickAcc = useCallback(\n    async (credentials: any) => {\n      if (!relayerURL) {\n        addToast('Email/pass accounts not supported without a relayer connection', {\n          error: true\n        })\n        return\n      }\n      if (!credentials.password) {\n        addToast('Password required to unlock the account', { error: true })\n        return\n      }\n      setLoading(true)\n      try {\n        const { signature, success, message, confCodeRequired } = await fetchPost(\n          fetch,\n          // network doesn't matter when signing\n          // if it does tho, we can use ${network.id}\n          `${relayerURL}/second-key/${account.id}/ethereum/sign${\n            isTypedData ? '?typedData=true' : ''\n          }`,\n          {\n            toSign: toSign.txn,\n            code: credentials.code?.length ? credentials.code : undefined\n          }\n        )\n        if (!success) {\n          setLoading(false)\n          if (!message) throw new Error('Secondary key: no success but no error message')\n          if (message.includes('invalid confirmation code')) {\n            addToast('Unable to sign: wrong confirmation code', { error: true })\n          }\n          addToast(`Second signature error: ${message}`, {\n            error: true\n          })\n          setConfirmationType(null)\n          setLoading(false)\n\n          return\n        }\n        if (confCodeRequired) {\n          setConfirmationType(confCodeRequired)\n\n          if (onConfirmationCodeRequired) {\n            await onConfirmationCodeRequired(confCodeRequired, approveQuickAcc)\n          }\n\n          setLoading(false)\n          return\n        }\n\n        if (!account.primaryKeyBackup)\n          throw new Error(\n            'No key backup found: you need to import the account from JSON or login again.'\n          )\n        const wallet = await Wallet.fromEncryptedJson(\n          JSON.parse(account.primaryKeyBackup),\n          credentials.password\n        )\n        const sig = await (isTypedData\n          ? signMessage712(\n              wallet,\n              account.id,\n              account.signer,\n              dataV4.domain,\n              dataV4.types,\n              dataV4.message,\n              signature\n            )\n          : signMessage(\n              wallet,\n              account.id,\n              account.signer,\n              getMessageAsBytes(toSign.txn),\n              signature\n            ))\n\n        await verifySignature(toSign, sig, requestedNetwork?.id)\n\n        addToast('Successfully signed!')\n\n        setSignedMessages([\n          ...signedMessages,\n          {\n            accountId: account.id,\n            networkId: requestedChainId,\n            date: new Date().getTime(),\n            typed: isTypedData,\n            signer: account.signer,\n            message: toSign.txn,\n            signature: sig,\n            dApp\n          }\n        ])\n\n        if (everythingToSign.length === 1) {\n          !!onLastMessageSign && onLastMessageSign()\n        }\n\n        // keeping resolve at the very end, because it can trigger components unmounting, and code after resolve may or may not run\n        resolve({ success: true, result: sig })\n      } catch (e) {\n        handleSigningErr(e)\n      }\n      setLoading(false)\n    },\n    [\n      account,\n      addToast,\n      dataV4,\n      everythingToSign,\n      fetch,\n      handleSigningErr,\n      isTypedData,\n      onConfirmationCodeRequired,\n      onLastMessageSign,\n      relayerURL,\n      requestedNetwork,\n      resolve,\n      toSign,\n      verifySignature,\n      dApp,\n      requestedChainId,\n      setSignedMessages,\n      signedMessages\n    ]\n  )\n  // Passing hardware device is required only for the mobile app\n  const approve = useCallback(\n    async (credentials: any, device?: any) => {\n      if (account.signer?.quickAccManager) {\n        await approveQuickAcc(credentials)\n        return\n      }\n      setLoading(true)\n\n      try {\n        const wallet = await getHardwareWallet(device)\n\n        if (!wallet) {\n          return\n        }\n\n        // It would be great if we could pass the full data cause then web3 wallets/hw wallets can display the full text\n        // Unfortunately that isn't possible, because isValidSignature only takes a bytes32 hash; so to sign this with\n        // a personal message, we need to be signing the hash itself as binary data such that we match 'Ethereum signed message:\\n32<hash binary data>' on the contract\n\n        const sig = await (isTypedData\n          ? signMessage712(\n              wallet,\n              account.id,\n              account.signer,\n              dataV4.domain,\n              dataV4.types,\n              dataV4.message\n            )\n          : signMessage(wallet, account.id, account.signer, getMessageAsBytes(toSign.txn)))\n\n        await verifySignature(toSign, sig, requestedNetwork?.id)\n\n        addToast('Successfully signed!')\n\n        setSignedMessages([\n          ...signedMessages,\n          {\n            accountId: account.id,\n            networkId: requestedChainId,\n            date: new Date().getTime(),\n            typed: isTypedData,\n            signer: account.signer,\n            message: toSign.txn,\n            signature: sig,\n            dApp\n          }\n        ])\n\n        // keeping resolve at the very end, because it can trigger components unmounting, and code after resolve may or may not run\n        resolve({ success: true, result: sig })\n      } catch (e) {\n        handleSigningErr(e)\n      }\n      setLoading(false)\n    },\n    [\n      account,\n      addToast,\n      approveQuickAcc,\n      dataV4,\n      getHardwareWallet,\n      handleSigningErr,\n      requestedNetwork?.id,\n      resolve,\n      toSign,\n      isTypedData,\n      verifySignature,\n      signedMessages,\n      setSignedMessages,\n      dApp,\n      requestedChainId\n    ]\n  )\n\n  return {\n    approve,\n    approveQuickAcc,\n    toSign,\n    isLoading,\n    hasPrivileges,\n    hasProviderError,\n    typeDataErr,\n    isDeployed,\n    dataV4,\n    requestedNetwork,\n    requestedChainId,\n    isTypedData,\n    confirmationType,\n    verifySignature,\n    dApp\n  }\n}\n\nexport default useSignMessage\n","import networks from '../../constants/networks'\n\nexport const getNetworkByChainId = (chainId?: string | number) => {\n  if (!chainId) return null\n\n  return networks.find((n) => n.chainId === parseInt(chainId.toString(), 10))\n}\n\nexport const getNetworkById = (id: string | number) => {\n  return networks.find((n) => n.id === id)\n}\n","import useSignMessage from './useSignMessage'\n\nexport default useSignMessage\n","const supportedDApps: string[] = [\n  'https://snapshot.org',\n  'https://guild.xyz',\n  'https://sudoswap.xyz',\n  'https://evm-sigtools.ambire.com',\n  'https://app.swappin.gifts',\n  'https://staging.swappin.gifts/ref/ambire'\n]\n\nexport default supportedDApps\n","import useSignMessage from \"ambire-common/src/hooks/useSignMessage\"\nimport supportedDApps from \"ambire-common/src/constants/supportedDApps\"\n\nimport \"./SignMessage.scss\"\n\nimport { MdBrokenImage, MdCheck, MdClose, MdInfoOutline } from \"react-icons/md\"\nimport { toUtf8String, isHexString } from \"ethers/lib/utils\"\nimport * as blockies from \"blockies-ts\"\nimport { getWallet } from \"lib/getWallet\"\nimport { useToasts } from \"hooks/toasts\"\nimport { useState, useEffect, useRef } from \"react\"\nimport { Button, Loading, TextInput, ToolTip, DAppIncompatibilityWarningMsg } from \"components/common\"\n\nimport useLocalStorage from 'hooks/useLocalStorage'\n\nconst CONF_CODE_LENGTH = 6\n\nexport default function SignMessage({ everythingToSign, resolve, account, relayerURL, totalRequests }) {\n  const defaultState = () => ({ codeRequired: false, passphrase: \"\" })\n  const { addToast } = useToasts()\n  const [signingState, setSigningState] = useState(defaultState())\n  const [promiseResolve, setPromiseResolve] = useState(null)\n  const inputSecretRef = useRef(null)\n\n  const onConfirmationCodeRequired = async (confCodeRequired, approveQuickAcc) => {\n    const confCode = await new Promise((resolve) => {\n      setPromiseResolve(() => resolve)\n    })\n    if (!confCode) throw new Error(\"You must enter a confirmation code\")\n    await approveQuickAcc({\n      password: signingState.passphrase,\n      code: confCode\n    })\n\n    return\n  }\n\n  const getHardwareWallet = () => {\n    // if quick account, wallet = await fromEncryptedBackup\n    // and just pass the signature as secondSig to signMsgHash\n    const wallet = getWallet(\n      {\n        signer: account.signer,\n        signerExtra: account.signerExtra,\n        chainId: 1 // does not matter\n      }\n    )\n\n    return wallet\n  }\n\n  const {\n    approve,\n    toSign,\n    isLoading,\n    hasPrivileges,\n    hasProviderError,\n    typeDataErr,\n    isDeployed,\n    dataV4,\n    requestedNetwork,\n    requestedChainId,\n    isTypedData,\n    confirmationType,\n    dApp\n  } = useSignMessage({\n    fetch,\n    account,\n    everythingToSign,\n    relayerURL,\n    addToast,\n    resolve,\n    onConfirmationCodeRequired,\n    getHardwareWallet,\n    useStorage: useLocalStorage,\n  })\n\n  const isDAppSupported = dApp && supportedDApps.includes(dApp.url)\n\n  useEffect(() => {\n    if (confirmationType) inputSecretRef.current.focus()\n  }, [confirmationType])\n\n  if (!toSign || !account) return <></>\n\n  // should not happen unless chainId is dropped for some reason in addRequests\n  if (!requestedNetwork) {\n    return (\n      <div id='signMessage'>\n        <h3 className='error'>\n          Inexistant network for chainId : {requestedChainId}\n        </h3>\n        <Button\n          className='reject'\n          onClick={() => resolve({ message: \"signature denied\" })}\n        >\n          Reject\n        </Button>\n      </div>\n    )\n  }\n\n  if (typeDataErr)\n    return (\n      <div id='signMessage'>\n        <h3 className='error'>Invalid signing request: {typeDataErr}</h3>\n        <Button\n          className='reject'\n          onClick={() => resolve({ message: \"signature denied\" })}\n        >\n          Reject\n        </Button>\n      </div>\n    )\n\n  const handleInputConfCode = (e) => {\n    if (e.length === CONF_CODE_LENGTH) promiseResolve(e)\n  }\n\n  const handleSubmit = (e) => {\n    e.preventDefault()\n    approve({\n      password: signingState.passphrase\n    })\n  }\n\n  return (\n    <div id='signMessage'>\n      <div id='signingAccount' className='panel'>\n        <div className='title'>Signing with account</div>\n        <div className='content'>\n          <div className='signingAccount-account'>\n            <img\n              className='icon'\n              src={blockies.create({ seed: account.id }).toDataURL()}\n              alt='Account Icon'\n            />\n            {account.id}\n          </div>\n          <div className='signingAccount-network'>\n            on\n            <div\n              className='icon'\n              style={{ backgroundImage: `url(${requestedNetwork.icon})` }}\n            />\n            <div className='address'>{requestedNetwork.name}</div>\n          </div>\n        </div>\n      </div>\n      <div className='panel'>\n        <div className='title signMessageTitle'>\n          <span className='signMessageTitle-title'>Sign message</span>\n          <span className='signMessageTitle-signatureType'>\n            <ToolTip\n              label={`${\n                isTypedData\n                  ? \"An EIP-712 typed data signature has been requested\"\n                  : \"An ethSign ethereum signature type has been requested\"\n              }`}\n            >\n              <MdInfoOutline />{\" \"}\n              <span>{isTypedData ? \"EIP-712 type\" : \"standard type\"}</span>\n            </ToolTip>\n          </span>\n        </div>\n\n        <div className='request-message'>\n          <div className='dapp-message'>\n            {dApp ? (\n              <a\n                className='dapp'\n                href={dApp.url}\n                target='_blank'\n                rel='noreferrer'\n              >\n                <div\n                  className='icon'\n                  style={{ backgroundImage: `url(${dApp.icons ? dApp.icons[0] : 'none'})` }}\n                >\n                  <MdBrokenImage />\n                </div>\n                {dApp.name}\n              </a>\n            ) : (\n              \"A dApp \"\n            )}\n            is requesting your signature.\n          </div>\n          <span>\n            {totalRequests > 1\n              ? `You have ${totalRequests - 1} more pending requests.`\n              : \"\"}\n          </span>\n          {!isDAppSupported && <DAppIncompatibilityWarningMsg />}\n        </div>\n\n        <textarea\n          className='sign-message'\n          type='text'\n          value={\n            dataV4\n              ? JSON.stringify(dataV4, \"\\n\", \" \")\n              : toSign.txn !== \"0x\"\n              ? getMessageAsText(toSign.txn)\n              : \"(Empty message)\"\n          }\n          readOnly={true}\n        />\n\n        <div className='actions'>\n          <form onSubmit={handleSubmit}>\n            {account.signer.quickAccManager && isDeployed && (\n              <>\n                <TextInput\n                  password\n                  required\n                  minLength={3}\n                  placeholder='Account password'\n                  value={signingState.passphrase}\n                  onChange={(value) =>\n                    setSigningState({ ...signingState, passphrase: value })\n                  }\n                ></TextInput>\n                <input type='submit' hidden />\n              </>\n            )}\n\n            {confirmationType && (\n              <>\n                {confirmationType === \"email\" && (\n                  <span>\n                    A confirmation code has been sent to your email, it is valid\n                    for 3 minutes.\n                  </span>\n                )}\n                {confirmationType === \"otp\" && (\n                  <span>Please enter your OTP code</span>\n                )}\n                <TextInput\n                  ref={inputSecretRef}\n                  placeholder={\n                    confirmationType === \"otp\"\n                      ? \"Authenticator OTP code\"\n                      : \"Confirmation code\"\n                  }\n                  onInput={(value) => handleInputConfCode(value)}\n                />\n              </>\n            )}\n\n            {isDeployed === null && !hasProviderError && (\n              <div>\n                <Loading />\n              </div>\n            )}\n\n            {isDeployed === false && (\n              <div>\n                <h3 className='error'>You can't sign this message yet.</h3>\n                <h3 className='error'>\n                  You need to complete your first transaction on{\" \"}\n                  {requestedNetwork.name} network in order to be able to sign\n                  messages.\n                </h3>\n              </div>\n            )}\n\n            {hasPrivileges === false && (\n              <div>\n                <h3 className='error'>\n                  You do not have the privileges to sign this message.\n                </h3>\n              </div>\n            )}\n\n            {hasProviderError && (\n              <div>\n                <h3 className='error'>\n                  There was an issue with the network provider:{\" \"}\n                  {hasProviderError}\n                </h3>\n              </div>\n            )}\n\n            <div className='buttons'>\n              <Button\n                type='button'\n                danger\n                icon={<MdClose />}\n                className='reject'\n                onClick={() => resolve({ message: \"signature denied\" })}\n              >\n                Reject\n              </Button>\n              {isDeployed !== null && isDeployed && hasPrivileges && (\n                <Button type='submit' className='approve' disabled={isLoading}>\n                  {isLoading ? (\n                    <>\n                      <Loading />\n                      Signing...\n                    </>\n                  ) : (\n                    <>\n                      <MdCheck /> Sign\n                    </>\n                  )}\n                </Button>\n              )}\n            </div>\n          </form>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nfunction getMessageAsText(msg) {\n  if (isHexString(msg)) {\n    try {\n      return toUtf8String(msg)\n    } catch (_) {\n      return msg\n    }\n  }\n  return msg?.toString ? msg.toString() : msg + \"\" //what if dapp sends it as object? force string to avoid app crashing\n}\n"],"sourceRoot":""}