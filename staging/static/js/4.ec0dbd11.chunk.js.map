{"version":3,"sources":["../node_modules/adex-protocol-eth/js/ensureTypes.js","../node_modules/adex-protocol-eth/js/Bundle.js"],"names":["BN","require","Address","x","length","startsWith","Error","Bytes32","b","Buffer","from","slice","isBuffer","module","exports","Uint256","bn","isNeg","Bytes","Bytes32Array","bytes32Array","size","undefined","map","Channel","channel","leader","follower","guardian","tokenAddr","nonce","utils","AbiCoder","hexlify","arrayify","keccak256","Interface","Contract","BigNumber","ensure","IdentityABI","QuickAccManagerABI","IdentityInterface","Bundle","args","this","identity","network","signer","txns","gasLimit","signature","minFeeInUSDPerGas","recoveryMode","meta","gasTankFee","prototype","getNonce","provider","estimate","fetch","relayerURL","replacing","getNextNonce","gasTank","queryParams","Object","fromEntries","entries","filter","fetchPost","URLSearchParams","toString","res","sign","wallet","isSingleSigMode","isNaN","encoded","getSignable","hash","signMsg","submit","signatureTwo","cancel","UNPREDICTABLE_GAS_REGEX","message","address","quickAccManager","signatureOne","abiCoder","sigInner","encode","timelock","sig","domain","types","value","signMsg712","userTxnBundle","getChainID","accHash","one","two","mapSignatureV","sigRaw","useFinalDigestSigMode","signMessage","_signTypedData","typedDataSign","nonces","toNumber","code","getCode","url","body","headers","method","JSON","stringify","r","json","estimateNoRelayer","txParams","to","data","encodeFunctionData","blockTag","estimateGasWithCatch","error","success","match","getErrMsg","getFeeData","feeData","gasPrice","baseFee","feeInNative","slow","medium","fast","ape","ERROR_SIG","call","returnData","decode","tx","send","then","catch","e","signMessage712"],"mappings":"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","file":"static/js/4.ec0dbd11.chunk.js","sourcesContent":["const { BN } = require('bn.js')\n\nfunction Uint256(x) {\n\tconst bn = new BN(x, 10)\n\tif (bn.isNeg()) throw new Error('uint256 expected, negative number given')\n\treturn bn\n}\n\nfunction Address(x) {\n\tif (!(typeof x === 'string' && x.length === 42 && x.startsWith('0x')))\n\t\tthrow new Error('invalid address: must start with a 0x and be 42 characters long')\n\treturn x\n}\n\nfunction Bytes32(b) {\n\tif (typeof b === 'string' && b.startsWith('0x') && b.length === 66) {\n\t\treturn Buffer.from(b.slice(2), 'hex')\n\t}\n\tif (!(b.length === 32 && Buffer.isBuffer(b))) throw new Error('32 byte Buffer expected')\n\treturn b\n}\n\nfunction Bytes(b) {\n\tif (typeof b === 'string' && b.startsWith('0x')) {\n\t\treturn Buffer.from(b.slice(2), 'hex')\n\t}\n\tif (!Buffer.isBuffer(b)) throw new Error('Buffer expected')\n\treturn b\n}\n\nfunction Bytes32Array(bytes32Array, size) {\n\t// no size specified\n\tif (size === -1 || size === undefined) {\n\t\treturn bytes32Array.map(x => Bytes32(x))\n\t}\n\treturn bytes32Array.length === size && bytes32Array.map(x => Bytes32(x))\n}\n\nfunction Channel(channel) {\n\tAddress(channel.leader)\n\tAddress(channel.follower)\n\tAddress(channel.guardian)\n\tAddress(channel.tokenAddr)\n\tBytes32(channel.nonce)\n\treturn channel\n}\n\nmodule.exports = { Uint256, Bytes32, Address, Bytes, Bytes32Array, Channel }\n","const { AbiCoder, hexlify, arrayify, keccak256, Interface } = require('ethers').utils\nconst { Contract, BigNumber } = require('ethers')\n\nconst ensure = require('./ensureTypes')\n\nconst IdentityABI = require('../abi/Identity5.2')\nconst QuickAccManagerABI = require('../abi/QuickAccManager')\n\nconst IdentityInterface = new Interface(IdentityABI)\n\nfunction Bundle(args) {\n\tthis.identity = ensure.Address(args.identity)\n\tthis.network = args.network\n\t// @TODO validate this\n\tthis.signer = args.signer\n\tthis.txns = args.txns\n\tthis.gasLimit = args.gasLimit\n\tthis.nonce = args.nonce\n\tthis.signature = args.signature\n\tthis.minFeeInUSDPerGas = args.minFeeInUSDPerGas\n\tthis.recoveryMode = args.recoveryMode\n\tthis.meta = args.meta\n\tthis.gasTankFee = args.gasTankFee\n\treturn this\n}\n\nBundle.prototype.getNonce = async function(provider) {\n\tthis.nonce = await getNonce(provider, this)\n\treturn this.nonce\n}\n\nBundle.prototype.estimate = async function({ fetch, relayerURL, replacing, getNextNonce, gasTank }) {\n\tconst queryParams = Object.fromEntries(Object.entries({getNextNonce, gasTank}).filter(([_, v]) => v))\n\tconst res = await fetchPost(\n\t\tfetch,\n\t\t`${relayerURL}/identity/${this.identity}/${this.network}/estimate?${\n\t\t\t(new URLSearchParams(queryParams)).toString()\n\t\t}`,\n\t\t{ txns: this.txns, signer: this.signer, replacing, minFeeInUSDPerGas: this.minFeeInUSDPerGas }\n\t)\n\tthis.gasLimit = res.gasLimit\n\treturn res\n}\n\nBundle.prototype.sign = async function(wallet, isSingleSigMode) {\n\tif (isNaN(this.nonce)) throw new Error('nonce is not set')\n\tif (isNaN(this.gasLimit)) throw new Error('gasLimit is not set')\n\tconst encoded = getSignable(this, isSingleSigMode)\n\tconst hash = arrayify(keccak256(encoded))\n\tconst signature = await signMsg(wallet, hash)\n\tthis.signature = signature\n\treturn signature\n}\n\nBundle.prototype.submit = async function({ fetch, relayerURL }) {\n\tconst res = await fetchPost(\n\t\tfetch,\n\t\t`${relayerURL}/identity/${this.identity}/${this.network}/submit`,\n\t\t{\n\t\t\tnonce: this.nonce,\n\t\t\tsigner: this.signer,\n\t\t\ttxns: this.txns,\n\t\t\tgasLimit: this.gasLimit,\n\t\t\tsignature: this.signature,\n\t\t\tsignatureTwo: this.signatureTwo,\n\t\t\tmeta: this.meta,\n\t\t\tgasTankFee: this.gasTankFee\n\t\t}\n\t)\n\treturn res\n}\n\nBundle.prototype.cancel = async function({ fetch, relayerURL }) {\n\tconst res = await fetchPost(\n\t\tfetch,\n\t\t`${relayerURL}/identity/${this.identity}/${this.network}/cancel`,\n\t\t{ nonce: this.nonce, signer: this.signer }\n\t)\n\treturn res\n}\n\nconst UNPREDICTABLE_GAS_REGEX = /gas required exceeds allowance|always failing transaction|execution reverted/\nBundle.prototype.estimateNoRelayer = async function({ provider, replacing }) {\n\tconst txParams = {\n\t\tfrom: this.signer.quickAccManager || this.signer.address,\n\t\tto: this.identity,\n\t\tdata: IdentityInterface.encodeFunctionData('executeBySender', [this.txns])\n\t}\n\tconst blockTag = replacing ? 'latest' : 'pending'\n\tconst { error, gasLimit } = await estimateGasWithCatch(provider, blockTag, txParams)\n\tif (error && error.message.startsWith('execution reverted: ')) {\n\t\tconst message = error.message.slice(20)\n\t\treturn { success: false, message }\n\t}\n\tif (error) {\n\t\t// Match both the code and the regex to handle both errs from ethers and raw ones from nodes in case we use .send\n\t\tif (!(error.code === 'UNPREDICTABLE_GAS_LIMIT' || error.message.match(UNPREDICTABLE_GAS_REGEX)))\n\t\t\tthrow error\n\t\treturn { success: false, message: await getErrMsg(provider, txParams, blockTag) }\n\t}\n\tthis.gasLimit = gasLimit.toNumber()\n\t// @TODO EIP1559-optimized estimations (good first issue for external contributors)\n\tconst feeData = await provider.getFeeData()\n\tconst gasPrice = feeData.gasPrice.toNumber()\n\tconst baseFee = (gasPrice * gasLimit) / 1e18\n\treturn {\n\t\tsuccess: true,\n\t\tgasLimit: this.gasLimit,\n\t\tgasPrice,\n\t\tfeeInNative: {\n\t\t\tslow: baseFee * 0.9,\n\t\t\tmedium: baseFee * 1.0,\n\t\t\tfast: baseFee * 1.15,\n\t\t\tape: baseFee * 1.4\n\t\t}\n\t}\n}\n\nasync function signMessage(wallet, identity, signer, message, signatureTwo) {\n\tif (signer.address) return signMsg(wallet, message, true)\n\tif (signer.quickAccManager) {\n\t\tconst signatureOne = await signMsg(wallet, message, true)\n\t\t// the inner sig is the one that the QuickAccManager interprets by doing an abi.decode and sending each individual signature to isValidSignature\n\t\tconst abiCoder = new AbiCoder()\n\t\tconst sigInner = abiCoder.encode(\n\t\t\t['uint', 'bytes', 'bytes'],\n\t\t\t[signer.timelock, signatureOne, signatureTwo]\n\t\t)\n\t\t// 02 is the SmartWallet type sig; we're essentially formatting this as a smart wallet type sig, verified by the quickAccManager\n\t\tconst sig = `${sigInner + abiCoder.encode(['address'], [signer.quickAccManager]).slice(2)}02`\n\t\treturn sig\n\t}\n\tthrow new Error(`invalid signer object`)\n}\n\n\nasync function signMessage712(wallet, identity, signer, domain, types, value, signatureTwo) {\n\tif (signer.address) return signMsg712(wallet, domain, types, value)\n\tif (signer.quickAccManager) {\n\t\tconst signatureOne = await signMsg712(wallet, domain, types, value)\n\t\t// the inner sig is the one that the QuickAccManager interprets by doing an abi.decode and sending each individual signature to isValidSignature\n\t\tconst abiCoder = new AbiCoder()\n\t\tconst sigInner = abiCoder.encode(\n\t\t\t['uint', 'bytes', 'bytes'],\n\t\t\t[signer.timelock, signatureOne, signatureTwo]\n\t\t)\n\t\t// 02 is the SmartWallet type sig; we're essentially formatting this as a smart wallet type sig, verified by the quickAccManager\n\t\tconst sig = `${sigInner + abiCoder.encode(['address'], [signer.quickAccManager]).slice(2)}02`\n\t\treturn sig\n\t}\n\tthrow new Error(`invalid signer object`)\n}\n\nfunction getSignable(userTxnBundle, isSingleSigMode) {\n\tconst abiCoder = new AbiCoder()\n\tconst signer = userTxnBundle.signer\n\tif (signer.address)\n\t\treturn abiCoder.encode(\n\t\t\t['address', 'uint', 'uint', 'tuple(address, uint, bytes)[]'],\n\t\t\t[\n\t\t\t\tuserTxnBundle.identity,\n\t\t\t\tgetChainID(userTxnBundle.network),\n\t\t\t\tuserTxnBundle.nonce,\n\t\t\t\tuserTxnBundle.txns\n\t\t\t]\n\t\t)\n\tif (signer.quickAccManager) {\n\t\tconst accHash = keccak256(\n\t\t\tabiCoder.encode(\n\t\t\t\t['tuple(uint, address, address)'],\n\t\t\t\t[[userTxnBundle.signer.timelock, userTxnBundle.signer.one, userTxnBundle.signer.two]]\n\t\t\t)\n\t\t)\n\t\t// @TODO typed data\n\t\t// if (signer.isTypedData)\n\t\treturn abiCoder.encode(\n\t\t\t['address', 'uint', 'address', 'bytes32', 'uint', 'tuple(address, uint, bytes)[]', 'bool'],\n\t\t\t[\n\t\t\t\tsigner.quickAccManager,\n\t\t\t\tgetChainID(userTxnBundle.network),\n\t\t\t\tuserTxnBundle.identity,\n\t\t\t\taccHash,\n\t\t\t\tuserTxnBundle.nonce,\n\t\t\t\tuserTxnBundle.txns,\n\t\t\t\t!isSingleSigMode\n\t\t\t]\n\t\t)\n\t}\n\tthrow new Error(`invalid signer object`)\n}\n\nfunction getChainID(network) {\n\tif (network === 'ethereum') return 1\n\tif (network === 'polygon') return 137\n\tif (network === 'binance-smart-chain') return 56\n\tif (network === 'bsc') return 56\n\tif (network === 'fantom') return 250\n\tif (network === 'avalanche') return 43114\n\tif (network === 'arbitrum') return 42161\n\tif (network === 'moonbeam') return 1284\n\tif (network === 'moonriver') return 1285\n\tif (network === 'gnosis') return 100\n\tif (network === 'kucoin') return 321\n\tif (network === 'andromeda') return 1088\n\tif (network === 'cronos') return 25\n\tif (network === 'aurora') return 1313161554\n\tif (network === 'rinkeby') return 4\n\tif (network === 'optimism') return 10\n\tthrow new Error(`unsupported network ${network}`)\n}\n\nfunction mapSignatureV(sigRaw) {\n\tconst sig = arrayify(sigRaw)\n\tif (sig[64] < 27) sig[64] += 27\n\treturn hexlify(sig)\n}\n\nasync function signMsg(wallet, message, useFinalDigestSigMode = false) {\n\t// assert.equal(hash.length, 32, 'hash must be 32byte array buffer')\n\t// was 01 originally but to avoid prefixing in solidity, we changed it to 00\n\treturn `${mapSignatureV(await wallet.signMessage(message))}${useFinalDigestSigMode ? '00' : '01'}`\n}\n\nasync function signMsg712(wallet, domain, types, value) {\n\t// 00 is the enum number of SignatureMode.EIP712\n\tconst typedDataSign = await wallet._signTypedData(domain, types, value)\n\treturn `${mapSignatureV(typedDataSign)}00`\n}\n\nasync function getNonce(provider, userTxnBundle) {\n\ttry {\n\t\treturn (userTxnBundle.signer.quickAccManager\n\t\t\t? await new Contract(\n\t\t\t\t\tuserTxnBundle.signer.quickAccManager,\n\t\t\t\t\tQuickAccManagerABI,\n\t\t\t\t\tprovider\n\t\t\t  ).nonces(userTxnBundle.identity)\n\t\t\t: await new Contract(userTxnBundle.identity, IdentityABI, provider).nonce()\n\t\t).toNumber()\n\t} catch (e) {\n\t\t// means the identity isn't deployed, which certainly implies nonce 0\n\t\tif (e.code === 'CALL_EXCEPTION' && (await provider.getCode(userTxnBundle.identity)) === '0x')\n\t\t\treturn 0\n\t\tthrow e\n\t}\n}\n\nasync function fetchPost(fetch, url, body) {\n\tconst r = await fetch(url, {\n\t\theaders: { 'content-type': 'application/json' },\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify(body)\n\t})\n\treturn r.json()\n}\n\n// helpers for estimateNoRelayer\n\n// Signature of Error(string)\nconst ERROR_SIG = '0x08c379a0'\n\nasync function getErrMsg(provider, txParams, blockTag) {\n\t// .call always returns a hex string with ethers\n\ttry {\n\t\tconst returnData = await provider.call(txParams, blockTag)\n\t\treturn returnData.startsWith(ERROR_SIG)\n\t\t\t? new AbiCoder().decode(['string'], `0x${returnData.slice(10)}`)[0]\n\t\t\t: returnData\n\t} catch (e) {\n\t\t// weird infura case\n\t\tif (e.code === 'UNPREDICTABLE_GAS_LIMIT' && e.error) return e.error.message.slice(20)\n\t\tif (e.code === 'CALL_EXCEPTION') return 'no error string, possibly insufficient amount'\n\t\tif (e.code === 'INVALID_ARGUMENT') return `unable to deserialize: ${hexlify(e.value)}`\n\t\tthrow e\n\t}\n}\n\nasync function estimateGasWithCatch(provider, blockTag, tx) {\n\treturn (\n\t\tprovider\n\t\t\t.send('eth_estimateGas', [tx, blockTag])\n\t\t\t.then(gasLimit => ({ gasLimit: BigNumber.from(gasLimit) }))\n\t\t\t// with .send, the error is wrapped in another error\n\t\t\t.catch(e => (e.code === 'SERVER_ERROR' ? { error: e.error } : { error: e }))\n\t)\n}\n\n// getNonce(require('ethers').getDefaultProvider('homestead'), { identity: '0x23c2c34f38ce66ccc10e71e9bb2a06532d52c5e8', signer: {address: '0x942f9CE5D9a33a82F88D233AEb3292E680230348'}, txns: [] }).then(console.log)\n\nmodule.exports = { Bundle, signMessage, signMessage712, getSignable, signMsg, signMsg712 }\n"],"sourceRoot":""}