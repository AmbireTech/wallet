{"version":3,"sources":["lib/getWallet.js","lib/ledgerWebHID.js"],"names":["wallets","getWallet","signer","signerExtra","chainId","opts","id","address","one","getWalletNew","type","TrezorConnect","manifest","email","appUrl","providerTrezor","TrezorSubprovider","trezorConnectClientApi","networkId","_initialDerivedKeyInfo","hdKey","HDNode","fromExtendedKey","info","xpub","derivationPath","baseDerivationPath","getInitialDerivedKeyInfo","signMessage","hash","signPersonalMessageAsync","ethers","utils","hexlify","signTransaction","params","signTransactionAsync","from","sendTransaction","transaction","a","network","networks","find","n","Error","getProvider","broadcastProvider","getTransactionCount","nonce","gas","gasLimit","gasPrice","signedTx","isConnected","matchAddress","getAccountsAsync","addresses","map","i","toLowerCase","includes","_signTypedData","domain","types","value","domainSeparator","_TypedDataEncoder","hashDomain","hashStructMessage","hashStruct","getPrimaryType","data","getPayload","_initialDerivedKeyInfoAsync","initialDerivedKeyInfo","derivedKeyInfo","_findDerivedKeyInfoForAddress","path","_trezorConnectClientApi","ethereumSignTypedData","metamask_v4_compat","domain_separator_hash","message_hash","response","success","payload","signature","error","transportProtocol","ledgerSignMessage","ledgerSignTransaction","provider","ledgerGetAddresses","ledgerSignMessage712","LedgerSubprovider","ledgerEthereumClientFactoryAsync","ledgerEthereumBrowserClientFactoryAsync","wrapLatticeError","commKey","deviceId","client","latticeInit","latticeConnect","isPaired","errConnect","message","pair","latticeSignMessage","signedMsg","errSignMessage","latticeSignTransaction","serializedSigned","errSignTxn","latticeGetAddresses","res","errGetAddresses","latticeSignMessage712","window","ethereum","providers","Web3Provider","signerObject","getSigner","matchChain","listAccounts","accounts","match","length","getNetwork","fn","arg","apply","this","catch","e","ethUtil","require","connectedDevices","PARENT_HD_PATH","getTransport","TransportWebHID","list","opened","open","request","transport","getAccounts","close","parentKeyDerivationPath","getAddressInternal","then","o","err","statusCode","ledgerResponse","publicKey","Buffer","chainCode","mainAddress","addressOfHDKey","calculateDerivedHDKeyInfos","appEth","AppEth","ledgerTimeout","Promise","resolve","reject","timeoutHandle","setTimeout","race","getAddress","clearTimeout","txn","fromAddr","unsignedTxObj","serializedUnsigned","serialize","accountsData","substr","rsvResponse","intV","parseInt","v","Math","floor","r","s","signerAddress","account","signPersonalMessage","rsvReply","toString","signEIP712HashedMessage","count","derivedKeys","fullDerivationPath","derive","derivedKey","push","derivedPublicKey","ethereumAddressUnprefixed","publicToAddress","addHexPrefix"],"mappings":"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","file":"static/js/3.57f60d87.chunk.js","sourcesContent":["import { TrezorSubprovider } from '@0x/subproviders/lib/src/subproviders/trezor' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport TrezorConnect from '@trezor/connect-web'\nimport { ethers } from 'ethers'\nimport HDNode from 'hdkey'\nimport { LedgerSubprovider } from '@0x/subproviders/lib/src/subproviders/ledger' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport { ledgerEthereumBrowserClientFactoryAsync } from '@0x/subproviders/lib/src' // https://github.com/0xProject/0x-monorepo/issues/1400\nimport { ledgerSignMessage, ledgerSignTransaction, ledgerSignMessage712, ledgerGetAddresses } from './ledgerWebHID'\nimport { \n  latticeInit, \n  latticeConnect, \n  latticeSignMessage, \n  latticeSignTransaction, \n  latticeGetAddresses, \n  latticeSignMessage712\n } from 'lib/lattice'\nimport { _TypedDataEncoder } from 'ethers/lib/utils'\nimport { getProvider } from 'lib/provider'\nimport networks from 'consts/networks'\n\nlet wallets = {}\n\n// opts\n// passphrase: string\n// noCache: boolean\nexport function getWallet({ signer, signerExtra, chainId }, opts = {}) {\n  const id = `${signer.address || signer.one}${chainId}`\n  if (wallets[id]) return wallets[id]\n  return wallets[id] = getWalletNew({ signer, signerExtra, chainId }, opts)\n}\n\nfunction getWalletNew({ chainId, signer, signerExtra }, opts) {\n  if (signerExtra && signerExtra.type === 'trezor') {\n    TrezorConnect.manifest({\n      email: 'contactus@ambire.com',\n      appUrl: 'https://wallet.ambire.com'\n    })\n    const providerTrezor = new TrezorSubprovider({\n      trezorConnectClientApi: TrezorConnect,\n      networkId: chainId\n    })\n    providerTrezor._initialDerivedKeyInfo = getInitialDerivedKeyInfo(signerExtra)\n    // for Trezor/ledger, alternatively we can shim using https://www.npmjs.com/package/web3-provider-engine and then wrap in Web3Provider\n    return {\n      signMessage: hash => providerTrezor.signPersonalMessageAsync(ethers.utils.hexlify(hash), signer.address),\n      signTransaction: params => providerTrezor.signTransactionAsync({ ...params, from: signer.address }),\n      sendTransaction: async (transaction) => {\n        const network = networks.find(n => n.chainId === transaction.chainId)\n        if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n        const broadcastProvider = await getProvider(network.id)\n        if (!broadcastProvider) throw Error('no provider found for network : ' + network.id)\n\n        transaction.nonce = ethers.utils.hexlify(await broadcastProvider.getTransactionCount(transaction.from))\n        const gas = ethers.utils.hexlify(transaction.gas || transaction.gasLimit)\n        transaction.gasPrice = ethers.utils.hexlify(transaction.gasPrice)\n        \n        transaction = {\n          ...transaction,\n          gas // trezor params requires gas prop\n          // no chainId prop but chainId already known by providerTrezor\n        }\n        \n        const signedTx = await providerTrezor.signTransactionAsync(transaction)\n        \n        return broadcastProvider.sendTransaction(signedTx)\n      },\n      isConnected: async (matchAddress) => { // chain is provided to trezor. Not necessary to check network\n        const addresses = await providerTrezor.getAccountsAsync(100)\n        return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n      },\n      _signTypedData: async (domain, types, value) => {\n        \n        const domainSeparator = _TypedDataEncoder.hashDomain(domain)\n        const hashStructMessage = _TypedDataEncoder.hashStruct(_TypedDataEncoder.getPrimaryType(types), types, value)\n        const data = _TypedDataEncoder.getPayload(domain, types, value)\n        const initialDerivedKeyInfo = await providerTrezor._initialDerivedKeyInfoAsync()\n        const derivedKeyInfo = providerTrezor._findDerivedKeyInfoForAddress(initialDerivedKeyInfo, signer.address)\n        const path = derivedKeyInfo.derivationPath\n\n        const response = await providerTrezor._trezorConnectClientApi.ethereumSignTypedData({\n          path,\n          data,\n          metamask_v4_compat: true,\n          domain_separator_hash: domainSeparator,\n          message_hash: hashStructMessage\n        })\n\n        if (response.success) {\n          return `${response.payload.signature}`;\n        } else {\n            throw new Error(response.payload.error);\n        }\n      }\n    }\n  } else if (signerExtra && signerExtra.type === 'ledger') {\n    if (signerExtra.transportProtocol === 'webHID') {\n      return {\n        signMessage: hash => ledgerSignMessage(ethers.utils.hexlify(hash), signer.address),\n        signTransaction: params => ledgerSignTransaction(params, chainId),\n        sendTransaction: async (transaction) => {\n          const network = networks.find(n => n.chainId === transaction.chainId)\n          if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n          const provider = await getProvider(network.id)\n          if (!provider) throw Error('no provider found for network : ' + network.id)\n\n          transaction.nonce = ethers.utils.hexlify(await provider.getTransactionCount(transaction.from))\n\n          const signedTx = await ledgerSignTransaction(transaction, transaction.chainId)\n\n          return provider.sendTransaction(signedTx)\n        },\n        isConnected: async (matchAddress) => { // chain is provided to ledger. Not necessary to check network\n          const addresses = await ledgerGetAddresses()\n          if (addresses && addresses[0]) {\n            if (matchAddress) {\n              return !!addresses.find(a => a.toLowerCase() === matchAddress.toLowerCase())\n            }\n            return true\n          }\n          return false\n        },\n        _signTypedData: (domain, types, value) => {\n          const domainSeparator = _TypedDataEncoder.hashDomain(domain)\n          const hashStructMessage = _TypedDataEncoder.hashStruct(_TypedDataEncoder.getPrimaryType(types), types, value)\n          return ledgerSignMessage712(domainSeparator, hashStructMessage, signer.address)\n        }\n      }\n    } else {\n      const provider = new LedgerSubprovider({\n        networkId: chainId,\n        ledgerEthereumClientFactoryAsync: ledgerEthereumBrowserClientFactoryAsync,\n        baseDerivationPath: signerExtra.info.baseDerivationPath\n      })\n      return {\n        signMessage: hash => provider.signPersonalMessageAsync(ethers.utils.hexlify(hash), signer.address),\n        signTransaction: params => provider.signTransactionAsync({ ...params, from: signer.address }),\n        sendTransaction: async () => {\n          throw Error('Please use a chrome based browser to use Ledger')\n        },\n        isConnected: async (matchAddress) => { // chain is provided to ledger. Not necessary to check network\n          const addresses = await provider.getAccountsAsync(1)\n          return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n        },\n        _signTypedData: (domain, types, value) => {\n          throw Error('Please, use a chrome based browser to use 721 Typed signatures')\n        }\n      }\n    }\n  } else if (signerExtra && signerExtra.type === 'Lattice') {\n    return {\n      signMessage: async hash => {\n        return await wrapLatticeError(async hash => {\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { signedMsg, errSignMessage } = await latticeSignMessage(client, hash)\n          if (errSignMessage) throw new Error(errSignMessage)\n\n          return signedMsg\n        }, [hash])\n      },\n      signTransaction: async params => {\n        return await wrapLatticeError( async params => {\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { serializedSigned, errSignTxn } = await latticeSignTransaction(client, params, chainId)\n          if (errSignTxn) throw new Error(errSignTxn)\n\n          return serializedSigned\n        }, [params])\n      },\n      sendTransaction: async transaction => { \n        return await wrapLatticeError(async (transaction) => {\n          const network = networks.find(n => n.chainId === transaction.chainId)\n          if (!network) throw Error('no network found for chainId : ' + transaction.chainId)\n          const broadcastProvider = await getProvider(network.id)\n          if (!broadcastProvider) throw Error('no provider found for network : ' + network.id)\n          transaction.nonce = ethers.utils.hexlify(await broadcastProvider.getTransactionCount(transaction.from))\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const { isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { serializedSigned, errSignTxn } = await latticeSignTransaction(client, transaction, chainId)\n          if (errSignTxn) throw new Error(errSignTxn)\n\n          return broadcastProvider.sendTransaction(serializedSigned)\n        }, [transaction])\n      },\n      isConnected: async matchAddress => { \n        return await wrapLatticeError(async (matchAddress) => {\n          let addresses = null\n\n          const { commKey, deviceId } = signerExtra\n          const client = latticeInit(commKey)\n          const { isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n          if (errConnect) throw new Error(errConnect.message || errConnect)\n\n          if (!isPaired) {\n            // Canceling the visualization of the secret code on the device's screen.\n            client.pair('')\n            throw new Error('The Lattice device is not paired! Please re-add your account!')\n          }\n\n          const { res, errGetAddresses } = await latticeGetAddresses(client)\n          if (errGetAddresses) { \n            throw new Error(`Lattice: ${errGetAddresses}`, { error: true })\n          }\n\n          addresses = res\n          return addresses.map(i => i.toLowerCase()).includes(matchAddress.toLowerCase())\n        }, [matchAddress])\n    },\n    _signTypedData: async (domain, types, value) => {\n      return await wrapLatticeError(async (domain, types, value) => {\n        const payload = _TypedDataEncoder.getPayload(domain, types, value)\n        const { commKey, deviceId } = signerExtra\n        const client = latticeInit(commKey)\n        const {isPaired, errConnect } = await latticeConnect(client, deviceId)\n\n        if (errConnect) throw new Error(errConnect.message || errConnect)\n\n        if (!isPaired) {\n          // Canceling the visualization of the secret code on the device's screen.\n          client.pair('')\n          throw new Error('The Lattice device is not paired! Please re-add your account!')\n        }\n\n        const { signedMsg, errSignMessage } = await latticeSignMessage712(client, payload)\n        if (errSignMessage) throw new Error(errSignMessage)\n\n        return signedMsg\n      }, [domain, types, value])\n    }\n  }\n  } else if (signer.address) {\n    if (!window.ethereum) throw new Error('No web3 support detected in your browser: if you created this account through MetaMask, please install it.')\n    // NOTE: for metamask, use `const provider = new ethers.providers.Web3Provider(window.ethereum)`\n    // 'any' is explained here: https://github.com/ethers-io/ethers.js/issues/1107\n    const provider = new ethers.providers.Web3Provider(window.ethereum, 'any')\n\n    const signerObject = provider.getSigner(signer.address)\n\n    signerObject.isConnected = async (matchAddress, matchChain) => {\n      const accounts = await provider.listAccounts()\n\n      let match = true\n      if (!!(accounts.length)) {\n        if (matchAddress) {\n          match = !!accounts.find(a => a.toLowerCase() === matchAddress.toLowerCase())\n        }\n        if (matchChain) {\n          const { chainId } = await provider.getNetwork()\n          match = match && chainId === matchChain\n        }\n      } else {\n        match = false\n      }\n      return match\n    }\n\n    return signerObject\n  } else if (signer.one) {\n    throw new Error('getWallet not applicable for QuickAccounts: use primaryKeyBackup with the passphrase and /second-sig')\n  } else {\n    throw new Error('unknown signer type')\n  }\n}\n\nfunction getInitialDerivedKeyInfo(signerExtra) {\n  return {\n    hdKey: HDNode.fromExtendedKey(signerExtra.info.hdKey.xpub),\n    derivationPath: signerExtra.info.derivationPath,\n    baseDerivationPath: signerExtra.info.baseDerivationPath\n  }\n}\n\nasync function wrapLatticeError(fn, arg) {\n  return await fn.apply(this, arg)\n   .catch(e => {\n     throw new Error(`Lattice: ${e.message}`)\n    })\n}\n","import TransportWebHID from '@ledgerhq/hw-transport-webhid'\nimport AppEth from '@ledgerhq/hw-app-eth'\nimport { serialize } from '@ethersproject/transactions'\n\nconst EIP_155_CONSTANT = 35\n\nconst ethUtil = require('ethereumjs-util')\nconst HDNode = require('hdkey')\n\nlet connectedDevices = null\n\nexport const PARENT_HD_PATH = \"44'/60'/0'/0\"\n\nasync function getTransport() {\n  connectedDevices = await TransportWebHID.list()\n  if (connectedDevices.length) {\n    if (connectedDevices[0].opened) {\n      return new TransportWebHID(connectedDevices[0])\n    } else { // when transport is still not closed and time between 2 requests is short\n      return TransportWebHID.open(connectedDevices[0])\n    }\n  } else {\n    try {\n      return await TransportWebHID.request()\n    } catch (e) {\n      if (e.message.includes('reading \\'open\\'')) {\n        throw new Error('ledger WebHID request denied')\n      }\n      throw new Error('Could not request WebHID ledger: ' + e.message)\n    }\n  }\n}\n\nexport async function ledgerGetAddresses() {\n  const transport = await getTransport()\n  const accounts = await getAccounts(transport)\n  transport.close()\n\n  return accounts.map(a => a.address)\n}\n\nasync function getAccounts(transport) {\n  const parentKeyDerivationPath = `m/${PARENT_HD_PATH}`\n  let ledgerResponse\n  ledgerResponse = await getAddressInternal(transport, parentKeyDerivationPath).then(o => o).catch(err => {\n    if (err.statusCode === 25871 || err.statusCode === 27404) {\n      throw Error('Please make sure your ledger is unlocked and running the Ethereum app. ' + err.message)\n    } else {\n      throw Error('Could not get address from ledger : ' + err)\n    }\n  })\n\n  const hdKey = new HDNode()\n  hdKey.publicKey = Buffer.from(ledgerResponse.publicKey, 'hex')\n  hdKey.chainCode = Buffer.from(ledgerResponse.chainCode, 'hex')\n  const mainAddress = addressOfHDKey(hdKey)\n\n  const initialDerivedKeyInfo = {\n    hdKey,\n    address: mainAddress,\n    derivationPath: parentKeyDerivationPath,\n    baseDerivationPath: PARENT_HD_PATH,\n  }\n\n  // currently we can't get addrs to match with what appears in MM/Ledger live so only one is derived\n  return calculateDerivedHDKeyInfos(initialDerivedKeyInfo, 1)\n}\n\n\nasync function getAddressInternal(transport, parentKeyDerivationPath) {\n  let timeoutHandle\n  const appEth = new AppEth(transport)\n\n  const ledgerTimeout = new Promise((resolve, reject) => {\n    timeoutHandle = setTimeout(() => {\n      return reject(new Error('Device took too long to respond...'))\n    }, 10000)\n  })\n\n  return Promise.race([\n    appEth.getAddress(parentKeyDerivationPath, false, true),\n    ledgerTimeout\n  ]).then((res) => {\n    clearTimeout(timeoutHandle)\n    return res\n  })\n}\n\nexport async function ledgerSignTransaction(txn, chainId) {\n  const transport = await getTransport()\n\n  const fromAddr = txn.from\n\n  const unsignedTxObj = {\n    ...txn,\n    gasLimit: txn.gasLimit || txn.gas,\n    chainId: chainId\n  }\n  delete unsignedTxObj.from\n  delete unsignedTxObj.gas\n\n  let serializedUnsigned = serialize(unsignedTxObj)\n  const accountsData = await getAccounts(transport)\n\n  //Managing only 1 addr for now\n  const address = accountsData[0].address\n\n  let serializedSigned\n  if (address.toLowerCase() === fromAddr.toLowerCase()) {\n    let rsvResponse\n    try {\n      rsvResponse = await new AppEth(transport).signTransaction(accountsData[0].derivationPath, serializedUnsigned.substr(2))\n    } catch (e) {\n      throw new Error('Could not sign transaction ' + e)\n    }\n\n    const intV = parseInt(rsvResponse.v, 16)\n    const signedChainId = Math.floor((intV - EIP_155_CONSTANT) / 2)\n\n    if (signedChainId !== chainId) {\n      throw new Error('Invalid returned V 0x' + rsvResponse.v)\n    }\n\n    delete unsignedTxObj.v\n    serializedSigned = serialize(unsignedTxObj, {\n      r: '0x' + rsvResponse.r,\n      s: '0x' + rsvResponse.s,\n      v: intV\n    })\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n\n  transport.close()\n\n  return serializedSigned\n}\n\nexport async function ledgerSignMessage(hash, signerAddress) {\n  const transport = await getTransport()\n\n  const accountsData = await getAccounts(transport)\n\n  //TODO for multiple accs?\n  const account = accountsData[0]\n\n  let signedMsg\n  if (account.address.toLowerCase() === signerAddress.toLowerCase()) {\n    try {\n      const rsvReply = await new AppEth(transport).signPersonalMessage(account.derivationPath, hash.substr(2))\n      signedMsg = '0x' + rsvReply.r + rsvReply.s + rsvReply.v.toString(16)\n    } catch (e) {\n      throw new Error('Signature denied ' + e.message)\n    }\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n  transport.close()\n  return signedMsg\n}\n\nexport async function ledgerSignMessage712(domainSeparator, hashStructMessage, signerAddress) {\n  const transport = await getTransport()\n\n  const accountsData = await getAccounts(transport)\n\n  //TODO for multiple accs?\n  const account = accountsData[0]\n\n  let signedMsg\n  if (account.address.toLowerCase() === signerAddress.toLowerCase()) {\n    try {\n      const rsvReply = await new AppEth(transport).signEIP712HashedMessage(account.derivationPath, domainSeparator, hashStructMessage)\n      signedMsg = '0x' + rsvReply.r + rsvReply.s + rsvReply.v.toString(16)\n    } catch (e) {\n      throw new Error('Signature denied ' + e.message)\n    }\n  } else {\n    throw new Error('Incorrect address. Are you using the correct account/ledger?')\n  }\n  transport.close()\n  return signedMsg\n}\n\nfunction calculateDerivedHDKeyInfos(initialDerivedKeyInfo, count) {\n  const derivedKeys = []\n  for (let i = 0; i < count; i++) {\n\n    const fullDerivationPath = `m/${initialDerivedKeyInfo.baseDerivationPath}/${i}`\n    const path = `m/${i}`\n    const hdKey = initialDerivedKeyInfo.hdKey.derive(path)\n    const address = addressOfHDKey(hdKey)\n    const derivedKey = {\n      address,\n      hdKey,\n      baseDerivationPath: initialDerivedKeyInfo.baseDerivationPath,\n      derivationPath: fullDerivationPath,\n    }\n\n    derivedKeys.push(derivedKey)\n  }\n  return derivedKeys\n}\n\nexport function addressOfHDKey(hdKey) {\n  const shouldSanitizePublicKey = true\n  const derivedPublicKey = hdKey.publicKey\n  const ethereumAddressUnprefixed = ethUtil\n    .publicToAddress(derivedPublicKey, shouldSanitizePublicKey)\n    .toString('hex')\n  return ethUtil.addHexPrefix(ethereumAddressUnprefixed).toLowerCase()\n}\n"],"sourceRoot":""}